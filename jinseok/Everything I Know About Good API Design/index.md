# Everything I Know About Good API Design

좋은 API 설계에 대해 내가 알고 있는 모든 것

## 1. API와 프론트엔드 개발자

- 프론트엔드 개발자는 백엔드 API의 **최대 소비자**이자 **검증자**
- **좋은 API의 기준**을 알아야 백엔드 개발자와 논리적으로 협의할 수 있음
- Next.js API Routes 나 BFF 도 API 설계 원칙을 따라야 함

## 2. API 설계의 본질

### "좋은 API는 지루하다 (Boring is Good)"

- **공급자의 욕심:** API를 화려하고 정교하게 설계하고 싶어함
- **사용자의 입장:** API는 그저 데이터를 가져오는 **도구**일 뿐
- **핵심:**
  - 좋은 API는 **처음 봐도 어떻게 쓸지 감이 온다**
  - 문서를 읽기 전에 이미 사용법을 예측할 수 있어야 한다
  - 사용자가 API 자체를 고민하게 만든다면, 그 API는 이미 실패

> API 사용자가 API에 대해 생각하는 시간 = 낭비되는 시간

### API는 바꾸기 어렵다

- 한 번 공개되면 **변경 비용이 매우 큼**
- 인터페이스 변경 → 사용자 코드 깨짐
- → API 설계는 “지금의 단순함”과 “장기적인 유연성” 사이의 균형을 찾는 일

## 3. 사용자 공간을 파손하지 마십시오 (WE DO NOT BREAK USERSPACE)

- **가장 중요한 원칙**: API 유지보수자로서 사용자에게 피해를 주는 것을 피하는 것은 신성한 의무

  - 하나의 API 변경이 **수백~수천 개의 하위 시스템을 연쇄적으로 망가뜨릴 수 있음**
  - HTTP referer 오타가 아직도 남아있는 이유도 동일 → **깔끔함보다 안정성**

- **절대 깨면 안 되는 것**

  - 필드 삭제 ❌
  - 필드 타입 변경 ❌
  - JSON 구조 변경 ❌

- **허용되는 변경**

  - **필드 추가** ✅

- **다만 리눅스조차도 모든 API를 영원히 지키지 않았음**
  - → 프론트엔드가 의존해도 되는 정책이 무엇인지 명확히 해둔다.
    - 이 필드는 추가만 되는가, 의미도 바뀔 수 있는가?
    - 이 enum 값은 확장 가능한가, 고정인가?
    - 이 에러 코드는 **UI 분기 로직에 써도 되는 안정적인 정책인가?**

## 4. 어쩔 수 없이 바꿔야 할 때: 버저닝

불가피하게 파괴적인 변경이 필요한 경우, 기존 사용자 공간을 파손하지 않으면서 새로운 버전을 제공하기 위함

- **일반적인 방법:**

  - **URL에 포함:** `/v1/api/resource`, `/v2/api/resource`
  - **헤더 사용:** `Stripe`처럼 헤더나 UI에서 기본 버전을 설정하도록 허용.

- **버저닝의 현실:**
  - 사용자 마이그레이션: 수개월 ~ 수년
  - 새로운 버전을 추가할 때마다 유지해야 할 엔드포인트 수가 크게 증가
  - API 문서, 테스트, CS, 운영 등 부담 증가

> 버저닝은 해결책이지만, 동시에 기술 부채
> 👉 **최후의 수단으로만 사용**

## 5. API와 Product

- **제품의 가치가 핵심:**

  - API가 아무리 좋아도 **제품이 별로면 아무도 안 씀**
  - **제품이 충분히 가치 있다면,** API가 엉망이더라도 사용자들은 이를 사용
    - 예: Facebook, Jira
  - API 품질은 **경쟁하는 두 제품 중 하나를 선택할 때만 고려되는 부가적인 기능**

- **설계가 나쁜 제품은 나쁜 API를 만든다**
  - API 디자인은 보통 제품의 구조를 따름
  - 제품의 데이터 모델링이 엉망이면 API도 필연적으로 어색해짐
    - 예: 댓글을 연결 리스트로 저장하는 시스템
  - UI에서는 숨길 수 있는 기술적 제약이 API에서는 드러나므로, 사용자에게 시스템 설계를 불필요하게 이해시켜야 함
    - → _FE가 화면 기획 단계에서 데이터 구조에 대해 피드백을 줘야 하는 이유_

## 6. 실질적인 디자인 조언

### 인증 (Authentication)

- **API Key는 반드시 제공하자**

  - OAuth만 제공 ❌
  - API Key + OAuth ✅

- **이유**
  - 간단한 스크립트를 시작하는 가장 쉬운 방법
    - 모든 API 사용은 간단한 스크립트에서 시작됨
  - 사용자는 개발자가 아닐 수도 있음 (영업 사원, 학생, 취미 개발자 등)
    - OAuth 핸드셰이크와 같은 복잡한 과정을 요구하면 많은 사용자가 어려움을 겪을 수 있음

> “쉽게 시작할 수 없음” = API 사용 포기

### 멱등성(Idempotency)과 재시도

- **상황:** 액션을 취하는 API(예: 댓글 생성, 송금) 요청이 500 에러나 타임아웃으로 실패

  - → 실제 작업이 수행되었는지 확실하지 않으면 재시도 시 **중복 생성**의 위험이 있음

- **해결책: 멱등성 키** 패턴

  1.  요청(헤더 또는 파라미터)에 사용자 정의 문자열인 멱등성 키를 포함하여 요청
  2.  서버는 해당 키를 가진 요청을 이전에 처리했는지 확인하고, 처리한 적 있다면 작업을 다시 수행하지 않고 저장된 결과를 반환
  3.  이를 통해 **중복 생성 없이 안전하게 재시도**할 수 있음

- **적용 범위:**
  - 보통 읽기 요청이나 리소스 ID로 삭제 요청에는 필요하지 않음
    - DELETE는 ID를 멱등성 키로 사용할 수 있음

### 속도 제한 (Rate Limiting)

- **API의 위험성:**

  - API는 클릭 속도가 아니다. 코드 속도로 호출됨
  - 의도치 않은 사용만으로도 서버를 죽일 수 있음
    - _`useEffect` 의존성 실수로 무한 요청을 보냈을 때 서버가 죽는다면?_

- **대책:**
  - **속도 제한 적용:** 특히 비용이 많이 드는 작업에 대해서는 더 엄격하게 적용
  - **일시적 비활성화 기능:** 특정 고객에 대해 API를 일시적으로 비활성화할 수 있는 기능을 준비
  - **메타데이터 제공:** 응답에 `X-Limit-Remaining`, `Retry-After` 헤더를 포함하여 클라이언트가 API를 잘 사용하도록 유도

> 백엔드는 `429 Too Many Requests`를 응답
> → 응답 헤더(`Retry-After`)를 보고 FE가 UI에 "잠시 후 다시 시도해주세요" 표시

### 페이지네이션 (Pagination)

- **Offset 기반 (`page=2`):**

  - 구현 쉽고, 페이지 번호 UI에 적합
  - 오프셋이 커질수록 데이터베이스가 매번 오프셋만큼 건너뛰어야 하므로 **속도가 느려짐**

- **Cursor 기반 (`cursor=last_id`):**

  - 이전 페이지의 마지막 레코드 ID나 토큰을 다음 요청에 전달
  - 데이터베이스가 색인된 커서 위치를 즉시 찾을 수 있어 **데이터셋 크기에 상관없이 빠름**

- 대규모 데이터셋이 될 수 있는 경우, 항상 커서 기반 페이지네이션을 권장
- API 목록 응답에 `next_page` 필드를 포함하여 다음 페이지 정보를 제공하면 편리함

### Optional Fields vs GraphQL

- **문제:**

  - API 응답의 일부 필드가 서버에서 제공하기에 비용이 많이 드는 경우

- **해결책:**
  - 해당 필드를 **선택 사항**으로 만들고 기본적으로는 제공하지 않음
    - 예: `?include_subscription=true` 와 같이 필요한 경우에만 포함하도록
- **GraphQL:** 필요한 데이터를 단일 쿼리로 요청하는 방식
  - **단점 (저자의 의견):**
    1. **진입 장벽:** 비엔지니어 및 많은 엔지니어에게 이해하기 어려움
    2. **임의 쿼리:** 캐싱이 복잡해지고 고려해야 할 엣지 케이스가 늘어
    3. **백엔드 구현 복잡성:** 표준 REST API보다 더 까다로움
  - **권장:** 유연성이 필수적인 경우가 아니라면 GraphQL은 과할 수 있음

### Internal API

- **차이점:**
  - 사용자는 대부분 같은 회사의 전문 개발자
  - 사용자 수가 적고, 코드를 직접 수정할 수 있으므로 **파괴적인 변경도 허용 가능**
  - 더 복잡한 인증 형태도 OK

> 그럼에도 '멱등성', '속도 제한' 등 안전장치와 사고 대응 설계는 여전히 중요하다.

## 7. 요약

- API는 유연해야 하면서도 단순해야 하므로 설계가 어렵다.
- API 유지보수자의 주된 의무는 **사용자 공간을 파손하지 않는 것**이다
- API 버저닝은 필요악
- API 품질보다 중요한 건 **제품 가치**. API는 사용자에게는 단지 '도구'일 뿐
- 제품 설계가 나쁘면 API 설계도 어려워진다.
- Side effect 요청은 **멱등성 키**를 포함하여 재시도를 안전하게 해야 한다.
- API는 장애의 원인이 될 수 있으므로, **속도 제한 및 킬 스위치**를 마련해야 한다.
- 대규모 데이터셋에는 **커서 기반 페이지네이션**을 권장
- 비용이 많이 드는 필드는 optional로 요청할 수 있도록 (GraphQL은 과할 수 있음)
- 내부 API는 퍼블릭 API와 다소 다른 규칙이 적용되지만 원칙은 동일하다.

## 8. 실무 적용 포인트

### 백엔드와의 협업

- **무한 스크롤 기능:** "Offset 말고 **Cursor Pagination**으로 API 만들어주세요."
- **중요한 생성(Create) 요청:** "네트워크 끊기면 재시도하게 **Idempotency Key** 지원해주세요."
- **에러 처리:** "단순 500 에러 말고, Rate Limit 걸리면 **429**랑 **재시도 시간** 헤더에 내려주세요."

### 직접 API를 만들 때

- **Breaking Change 주의:** 나중에 고치기 힘드니 처음에 필드명 신중하게 짓기.
- **복잡도 관리:** 멋있는 것보다 **"동료가 쓰기 편한(Boring)"** 구조가 최고.

### 에러 핸들링

- 백엔드가 Unexpected Field를 내려줘도 정상 동작해야 함
- 필드 타입이 바뀌거나 사라지는 건 백엔드 잘못: "WE DO NOT BREAK USERSPACE" 원칙

### 코드 설계에서의 교훈

- 우리가 만드는 React 컴포넌트나 함수도 그 자체로 하나의 API
  - 컴포넌트를 사용할 때 내부 코드를 보지 않아도 사용할 수 있는 컴포넌트가 좋은 컴포넌트
- 내부 vs 외부 구분
  - **공개 인터페이스:** 다른 팀이 사용하거나 외부에 공개되는 컴포넌트 → 안정성 보장
  - **내부 로직:** 컴포넌트 내부에서만 쓰이는 유틸리티 함수나 상태 → **필요하다면 변경 가능**
    - → API의 안정성은 설계자의 **선언(Declaration)** 에서 시작

## 9. 참고 링크

- https://www.seangoedecke.com/good-api-design/
