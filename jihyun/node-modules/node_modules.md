# node_modules

- 의존성 관리와 모듈 경로 해결 역할
- npm install 실행 → @npmcli/arborist가 의존성 트리를 분석 및 필요한 의존성 설치 → node_modules 폴더에 저장
  - package.json이라는 트리 (구조)의 수목 관리 전문가

## 주요 기능과 특징

- 의존성 관리
  - package.json에 명시된 의존성 목록을 기준으로 필요한 패키지 설치 및 관리
  - 앱을 배포하거나 공유하더라도 package.json을 기반으로 프로젝트 의존성을 일관되게 유지
- 경로 해결
  - require() 함수나 import 문으로 모듈을 가져올 때, 해당 모듈을 검색하는 주요 경로 역할
  - 외부 모듈 간편하게 로드 가능
- 네임스페이스 관리
  - 의존성 트리 내 여러 패키지가 동일한 이름의 모듈을 필요로 하는 경우가 많음
  - 이러한 중복 모듈이 서로 영향을 미치지 않도록 각 패키지가 독립적으로 사용할 수 있게 네임스페이스 관리
  - e.g. 서로 다른 두 패키지가 각각 다른 버전의 모듈을 요구한다면, 충돌 방지를 위해 하위 폴더로 분리 설치

## 구조

- 프로젝트에서 사용하는 패키지와 그 패키지들이 의존하는 다른 패키지들로 구성된 계층 구조
- e.g. `npm install react react-dom` 실행 후 node_modules 구조
  ```
  node_modules/
  ├── .bin
  ├── js-tokens
  ├── loose-envify
  ├── react
  ├── react-dom
  └── schedular
  ```
  - react와 react-dom의 의존성 패키지들이 함께 설치됨
    - 중복 설치를 피하기 위해 폴더 구조를 평탄화한 결과

### .bin 폴더

- package.json 파일에 정의된 bin 필드를 참조함
- bin 필드는 패키지의 실행 가능한 스크립트/바이너리 파일을 정의하는 데 사용
- loose-envify의 package.json을 보면 bin 필드가 있는데, loose-envify라는 실행 가능한 명령어로 cli.js를 실행한다는 뜻임

```json
{
  "name": "loose-envify",
  "version": "1.4.0",
  "bin": {
    "loose-envify": "cli.js"
  }
}
```

1. 이러한 패키지를 설치하면,
2. npm이나 yarn 같은 패키지 관리자는 각 패키지의 package.json에 포함된 bin 필드를 읽음
3. 해당 실행 파일들을 node_modules/.bin 폴더에 심볼릭 링크로 생성

```
node_modules/
├── .bin/
│   └── loose-envify --> ../loose-envify/cli.js
├── loose-envify/
│   ├── cli.js
│   └── package.json
└── ...
```

1. 심볼릭 링크 덕분에 터미널의 프로젝트 경로상에서 loose-envify 명령어를 직접 실행할 수 있음
   - 전역에서 설치된 패키지와 동일한 방식으로 동작
   - cli.js를 node로 실행한 것과 동일

- 결론적으로, .bin 폴더는 각 패키지의 package.json에 정의된 bin 필드의 각 명령어를 참조해서 실행 가능한 명령어를 제공하는 역할

### 서브 패키지 node_modules 폴더

- 여러 패키지에서 동일한 패키지의 동일 버전에 의존할 경우, 평탄화 작업을 통해 최상위 node_modules에 설치
- 그러나 의존하는 버전이 다르다면?
  - 개별 패키지의 node_modules 서브 폴더에 필요한 버전을 설치하여 관리
- e.g. axios@1.6.8 의존성 설치 → axios의 의존 패키지인 follow-redirects@1.15.6이 같은 node_moduels 수준에 위치
  ```
  node_modules/
  ├── axios/
  │   └── package.json # 1.6.8
  └── follow-redirects/
      └── package.json # 1.15.6
  ```
  - 이때 follow-redirects@1.0.0 (다른 버전)을 설치하면, follow-redirects@1.15.6을 axios 내부의 node_modules 서브 폴더에 배치
    - axios가 참조하는 follow-redirects 버전과 프로젝트가 직접 참조하는 follow-redirects 버전을 서로 다르게 유지할 수 있음
  ```
  node_modules/
  ├── axios/
  │   ├── node_modules/
  │   │   └── follow-redirects/
  │   │       └── package.json # 1.15.6
  │   └── package.json
  └── follow-redirects/
      └── package.json # 1.0.0
  ```

### .cache 폴더

- 빌드 도구와 패키지 관리 도구들이 성능 향상을 위해 캐시 데이터를 저장하는 장소
- 공식으로 지정한 폴더는 아니지만, 여러 라이브러리들이 성능 최적화를 위해 암묵적으로 사용하는 경로가 됨
- e.g. 웹팩과 바벨
  - 웹팩은 컴파일된 모듈과 빌드 아티팩트를 저장하여 이후 빌드시 캐시된 데이터를 활용함 → 빌드 시간 단축
  - 바벨도 컴파일 결과를 캐시 → 컴파일 속도 향상
- 즉, 빌드 도구와 컴파일러의 속도를 향상시킬 수 있고 반복적인 작업의 성능을 최적화하는데 도움

## 심볼릭 링크

- 파일 시스템 내에서 특정 파일이나 디렉터리에 대한 **참조를 다른 위치에 생성하는 기능**
  - node.js 뿐만 아니라 운영체제에서도 지원되는 일반적인 개념임
- 원본 경로를 참조해서 원본 파일에 접근하는 일종의 링크 역할
- 링크가 참조하는 모든 위치에서 원본 파일의 변경사항을 즉시 반영할 수 있음

### 심볼릭 링크 직접 활용하기

- 패키지 구현 후, 해당 package.json 파일이 위치한 경로에서 npm link 실행 → 패키지의 심볼릭 링크가 전역에 생성됨
- 이렇게 생성된 심볼릭 링크는 전역 node_modules 폴더에 위치
  - 즉, 다른 프로젝트에서도 로컬 패키지를 쉽게 참조할 수 있음
- 패키지를 수정했을 때, 수정사항은 이 심볼릭 링크를 사용하는 다른 프로젝트에도 반영됨

### 장점

- 개발 효율성
  - 로컬에서 개발 중인 패키지를 다른 프로젝트에서 테스트할 때 복사본을 만들 필요 없고
  - 변경사항을 즉시 반영 가능
- 저장 공간 절약
  - 동일한 파일을 여러 위치에 복사하는 대신 단일 원본 파일에 대한 참조
  - 여러 위치에서 접근 가능
- 빠른 업데이트
  - 원본 파일이 변경될 때 자동으로 최신 상태로 유지됨
  - 개발 생산성 증가

### node_modules에서 심볼릭 링크의 활용

#### node_modules/.bin

- node_modules/.bin 경로에는 외부 패키지의 bin 필드에 정의된 실행 파일들이 심볼릭 링크 형태로 추가됨
- e.g. eslint의 package.json
  ```json
  {
    "name": "eslint",
    "version": "9.2.0",
    "bin": {
      "eslint": "./bin/eslint.js"
    }
  }
  ```
  - eslint를 설치하면, node_modules/.bin 폴더에 eslint 실행 파일에 대한 심볼릭 링크가 생성됨
  ```
  node_modules/
  ├── .bin/
  │   └── eslint --> ../eslint/bin/eslint.js
  └── eslint/
      ├── bin/
      │   └── eslint.js
      └── package.json
  ```
  - 이 설정으로 package.json의 scripts 필드에서 eslint 명령어를 사용하거나 npx 명령어로 CLI 도구를 실행할 수 있음
  ```json
  {
    "scripts": {
      "lint": "eslint '**/*.{js, ts}'"
    }
  }
  ```
  ```bash
  npx eslint '**/*.{js, ts}'
  ```

→ 즉, node_modules/.bin 폴더는 프로젝트 내에 설치된 CLI 도구들을 효율적으로 관리하고, 쉽게 실행할 수 있도록 돕는 역할

#### 워크스페이스

- npm의 워크스페이스 기능에서도 심볼릭 링크가 활용됨
  - 워크스페이스란, 여러 패키지를 하나의 프로젝트 내에서 함께 관리할 수 있게 해주는 기능
  - package.json의 workspaces 필드를 통해 관리할 패키지들의 경로를 지정할 수 있음
- 워크스페이스를 사용하면 각 패키지가 node_modules 폴더 내에 심볼릭 링크로 연결됨
- 따라서 의존성 설치할 때 별도의 패키지 관리 없이도 각 패키지 간의 참조가 자동으로 처리됨
- e.g. 모노레포
  ```
  monorepo-packages/
  ├── package-A/
  │   └── package.json
  ├── package-B/
  │   └── package.json
  └── package.json
  ```
  ```json
  {
    "name": "monorepo-packages",
    "private": true,
    "workspaces": ["packages/*"]
  }
  ```
  - 각 패키지는 서로 참조할 때 심볼릭 링크를 통해 연결됨
  - package-A가 package-B를 의존성으로 가진다면
    - npm은 packages/package-A/node_modules/package-B에 심볼릭 링크를 생성
      - packages/package-B를 참조
  ```json
  monorepo-packages/
  ├── package-A/
  │   └── node_modules/
  │       └── package-B --> ../../package-B
  ├── package-B/
  │   └── package.json
  └── package.json
  ```

→ 즉, 다수의 패키지를 포함하는 모노레포 환경에서 중복을 줄이고, 워크스페이스 간의 의존성을 간편하게 관리하는 데 유용

#### 패키지 관리자

- 패키지 관리 도구인 pnpm에서도 활용됨
  - pnpm이란, 디스크 공간 절약과 패키지 설치 속도 향상을 위해 심볼릭 링크를 적극적으로 활용하는 패키지 관리자
  - 이 얘기는 너무 길어져서 다음에 시간되면 다루겠음~

# 정리

- node_modules는 의존성을 설치하고 관리
- 뿐만 아니라 빌드 도구와 패키지 관리자들이 성능 최적화를 위해 활용함
- 캐시 데이터를 저장하거나 심볼릭 링크를 생성해서 프로젝트의 일관성과 성능을 향상시키는 중요한 역할

---

출처: npm Deep Dive
