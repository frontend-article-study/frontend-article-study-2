# 어떤 버그든 고치는 방법

[https://kofearticle.substack.com/p/korean-fe-article-4be](https://kofearticle.substack.com/p/korean-fe-article-4be)

# 바이브 코딩 중 마주친 버그 디버깅 과정

## 버그 상황

- 웹앱의 라우트에서 일련의 카드들을 표시
- 각 카드는 다음 카드로 스크롤되는 버튼 보유
- 버튼에 서버 호출을 추가하자 스크롤이 망가짐 (화면이 흔들리고 이상해짐)
- React Router의 actions를 통한 원격 서버 호출이 scrollIntoView 호출에 간섭
- 처음에는 액션이 데이터 refetch를 유발해 페이지를 다시 렌더링하기 때문이라고 추측
- 하지만 서버는 동일한 아이템을 반환했기에 원칙적으로 진행 중인 스크롤에 간섭할 이유가 없었음

## Step 0: 그냥 고쳐보기

- 클로드에게 문제 해결을 요청
- 클로드의 시도들: scrollIntoView 호출이 포함된 useEffect의 조건 재작성, smooth 스크롤을 instant로 변경 등
- 매번 당당하게 문제를 해결했다고 선언했지만 실제로는 전혀 해결되지 않음
- 이는 클로드만의 문제가 아니라 인간 엔지니어들도 자주 하는 실수
- 클로드가 반복적으로 틀린 이유: **재현(Repro)이 없었기 때문**

## Step 1: 재현을 찾기

- 재현 또는 재현 케이스: 일정한 절차를 따를 때 버그가 여전히 발생하는지 신뢰할 수 있게 알려주는 지침의 모음
- 재현은 "무엇을 해야 하는지", "무엇이 기대되는지", "무엇이 실제로 일어나는지"를 명시

### 초기 재현 케이스

- 버튼을 클릭한다
- 기대되는 동작: 아래로 스크롤
- 실제 동작: 스크롤이 흔들림
- 이 버그는 매번 발생 (신뢰할 만한 재현)

### 재현의 문제점

- 클로드에게는 "스크롤이 흔들린다"는 표현이 아무 의미가 없음
- 클로드는 볼 수 없기 때문에 직접 흔들림을 인식할 방법이 없음
- 스크린샷으로도 흔들림은 포착되지 않음
- 클로드는 사실상 재현 없이, 즉 구체적으로 검증할 기준 없이 문제를 고치려 함
- 이런 상황은 사람 간의 협업에서도 흔함 (특정 사용자, 설정, 환경에서만 발생하는 버그 등)

### 재현 변경의 원칙

- 기존 재현을 다른 재현으로 바꾸더라도, 그것이 원래 문제 해결에 도움이 된다고 스스로 납득할 수 있다면 괜찮음

## Step 2: 재현을 좁히기

### 재현 변경의 위험성

- 새 재현이 원래 버그와 아무 관련이 없을 수도 있음
- 완전히 엉뚱한 문제를 고치느라 시간을 낭비할 가능성
- 하지만 클로드가 화면을 볼 수 없으므로 불가피
- 더 효율적인 반복 작업을 가능하게 함 (10분 걸리는 재현보다 10초 걸리는 재현이 훨씬 유용)

### 이상적인 재현의 특징

- 더 단순하고, 더 좁고, 더 직접적인 재현

### 새로운 재현 케이스 제안

1. 문서의 스크롤 위치를 측정
2. 버튼을 클릭
3. 다시 스크롤 위치를 측정
4. 기대한 동작: 위치에 변화가 있음
5. 실제 동작: 변화가 없음
- 이 방식은 원래 문제와 대체로 유사
- 흔들림 자체는 포착하지 못하지만 스크롤이 이동하지 않는 현상은 문제와 연관되어 있을 가능성이 높음
- 클로드가 console.log를 추가하고 Playwright MCP를 통해 페이지를 열고 클릭 시도
- 실제로 버튼 클릭 시 스크롤 위치가 변하지 않음을 확인
- 이제 클로드도 버그가 존재함을 "확인할 수 있게" 됨

### 재현 검증의 중요성

- "좋은 재현을 찾았다"라고 착각하지만 실제로는 유사한 증상을 보이는 전혀 다른 문제를 잡고 있는 경우가 있음
- 예: 스크롤 위치를 너무 일찍 읽고 있을 가능성 - 버그가 실제로 고쳐져도 위치가 변하지 않은 것처럼 보일 수 있음
- **새로운 재현 사례로도 정상 동작("모든 것이 잘 작동")을 여전히 재현할 수 있는지 반드시 확인 필요**

### 검증 과정

- 네트워크 호출을 주석 처리 (원래 버그를 유발했던 것)
- 새 재현이 원래 문제를 잘 포착하고 있다면, 이미 문제를 해결한다고 확인된 수정이 새 재현에서도 정상 동작을 만들어야 함
- 실제로 네트워크 호출을 주석 처리하자 스크롤 위치가 변함
- 코드를 몇 번 바꿔보면서 새 재현의 결과가 일관되게 예측되는지 확인
- 스크롤 측정 결과는 네트워크 호출과 연관이 있어 보임
- 새 재현이 원래 문제를 완전히 대변한다고 단정할 수는 없지만, 계속 진행할 충분한 이유가 됨

## Step 3: 다른 모든 것을 제거하기

### 작업 워크플로우

1. 재현을 실행해 버그가 실제로 존재함을 확인
2. 관련 코드에서 무언가를 제거 (컴포넌트, 이벤트 핸들러, 조건문, 스타일, import 등)
3. 재현을 다시 실행해 버그가 여전히 존재하는지 확인
4. 버그가 여전히 있으면 변경 사항을 커밋
5. 버그가 사라졌다면, 무엇이 "고친 것"일 수 있는지에 대한 가설을 작성하고, 마지막 커밋으로 리셋한 뒤 더 작은 단위를 삭제
- "버그를 더 이상 줄일 수 없을 때까지 계속하라"고 지시
- React Router조차 포함하지 않고 최소한의 로직만 남긴 리액트 컴포넌트 하나로 줄일 때까지

### 클로드의 실패와 그 이유

- 클로드가 만든 여러 재현 케이스 중 어느 것도 버그를 재현하지 못함
- 순수한 리액트 상태 업데이트, React Router 재검증, 컴포넌트 리마운트, 새로운 객체 참조, 동기 로더, 다양한 의존성 배열, 스크롤 중 다중 렌더링 등을 모두 테스트했지만 버그 재현 실패
- 버그는 실제 앱에서는 일관되게 재현되지만 어떤 재현에서도 발생하지 않음

### 클로드가 지시를 따르지 못한 방식

- 클로드는 코드를 단순화하는 과정에서 여러 이론을 세우기 시작
- "아마 이 effect가 문제일 거야", "컴포넌트가 리마운트 되면서 문제일 수도", "리액트가 이상한 일을 하는 건 아닐까" 등
- 각 이론을 검증하기 위해 관련된 재현을 만들고 테스트
- 하지만 실제로 버그가 존재하지 않는 여러 테스트 케이스를 만들어버림

### 핵심 원칙

- **항상 버그가 여전히 존재하는 상태의 체크포인트를 유지하면서, 조금씩 해당 버그의 발생 가능 영역을 줄여가야 함**
- 새로운 이론을 시험해 보는 것은 좋지만, 실패했다면 원래의 재현(여전히 버그가 있는 케이스)으로 돌아와서 그 케이스에서 요소를 하나씩 제거하며 진행해야 함

### 잘 정의된 재귀(well-founded recursion) 비유

- 피보나치 함수 예시: fib(n)을 호출할 때 실수로 fib(n)을 다시 호출하면 무한 루프
- Lean 같은 언어는 n이 "작아지지 않는다"는 것을 알고 타입 오류를 발생시킴
- 버그 재현을 줄여가는 과정도 동일: 항상 조금씩 진전하고, 재현이 점점 더 작아지고 있음을 보장해야 함
- 규율을 유지하며 조각을 조금씩 제거하고, 버그가 여전히 지속되는 경우에만 커밋
- 더 이상 제거할 것이 없을 때, 그때가 바로 원인을 찾은 순간

## Step 4: 근본 원인을 찾기

### 최종 해결 과정

- "지시를 제대로 따르라"라고 재지시
- 클로드가 정말로 불필요한 코드를 하나씩 제거
- 문제는 하나의 파일에 국한됨
- 그 파일을 라우터 밖으로 옮기자 갑자기 코드가 정상 작동
- 다시 라우터 안으로 옮기면 버그가 재현
- 파일을 최상위 라우트로 만들면 또 정상 작동
- **결론: 루트 레이아웃 안에 중첩될 때만 문제가 발생**

### 루트 레이아웃 코드

javascript

`import { Outlet, ScrollRestoration } from 'react-router-dom';

export function RootLayout() {
  return (
    <div>
      <ScrollRestoration />
      <Outlet />
    </div>
  );
}`

### 버그의 근본 원인

- React Router의 ScrollRestoration이 경로 변경 시마다 활성화되어야 하는데, 재검증(revalidation)마다 작동하는 버그가 있었음 (6월에 이미 수정됨)
- 네트워크 호출(액션을 통해 수행)이 라우트를 재검증하면서 scrollIntoView 중에 ScrollRestoration이 트리거되어 스크롤 흔들림 발생
- 클로드가 프로젝트를 설정할 때 이유를 알 수 없게도 핵심 의존성의 오래된 버전을 사용했기 때문에 발생
- 최신 버전을 사용했다면 이 버그를 마주하지 않았을 것

### 교훈

- "코드를 하나씩 제거하면서도 버그가 여전히 남아 있는지 확인하는" 접근법은 매우 효과적
- 더 이상 가설이 남지 않았을 때, 이 방법만큼 효과적인 건 없음
- 이것이 바로 바이브 코딩의 묘미!