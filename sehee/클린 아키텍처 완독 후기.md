# 읽게 된 배경

변경이 용이한 코드, 유지보수하기 쉬운 코드에 대해 탐구하다가, 언젠가 들은 원티드 프리온보딩에서 강사님이 클린 아키텍처를 많이 인용하시길래 저기에 답이 있겠다고 생각하고 읽게 되었다.

# 책의 구성

총 7부로 이루어져 있다.

- 1부 : 아키텍처의 중요성
- 2부~3부 : 프로그래밍 패러다임(구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍)에 대한 간략한 설명 및 설계 원칙(SOLID 원칙)에 대한 이론적 설명
- 4부~6부 : 컴포넌트(패키지), 아키텍처, 데이터베이스/웹/프레임워크 등 여러 차원의 시스템들에서 위 이론을 바탕으로 클린 아키텍처를 설계하는 법
- 7부 : 1970년부터 45년에 걸쳐 프로그래밍을 해온 저자의 프로젝트 경험담

# 클린 아키텍처의 중요성

> "소프트웨어 아키텍처의 목표는 시스템을 구축하고 유지보수하는 데 투입되는 인적 자원을 최소화하는 것이다."
> 

개발자들은 종종 지저분하게 코드를 짜면 빠른 구현이 가능하다고 생각하지만 저자는 이를 착각이라고 말한다.

엉망인 코드는 프로젝트 초반엔 빠를지 몰라도 시간이 지날수록 생산성을 0에 수렴하게 만들며, 코드를 깔끔하게 유지하는 것보다 항상 더 느리다는 관점이다.

# 용어 혼동

책은 자바 언어를 기반으로 작성되어 있고, 몇몇 용어(ex: 컴포넌트)를 프론트엔드 진영에서 사용하는 의미와 다르게 쓰고 있어서 헷갈리는 부분이 있었다.

그래서 특정 용어가 다르게 쓰이는 것 같으면 GPT에 물어봐서 뇌내 매핑을 한 채로 읽어야 이해가 잘 됐다.

다음은 클린 아키텍처에서의 용어를 프론트엔드 진영에서 사용하는 용어로 매핑한 테이블이다.

| **클린 아키텍처** | **해당하는 프론트엔드 용어** | **핵심 의미** |
| --- | --- | --- |
| **클래스 (Class)** | 함수형 컴포넌트, 훅, 유틸 함수 객체, 클래스 | **행위와 데이터의 최소 결합 단위** |
| **모듈 (Module)** | `.js`, `.ts`, `.tsx` 파일 하나 | **관련된 코드들이 모인 물리적/논리적 단위** |
| **컴포넌트 (Component)** | npm 패키지, 라이브러리 | **독립적으로 배포 가능한 덩어리** |
| **인터페이스 (Interface)** | TypeScript `interface` / `type`, Props 정의 | **구체적인 구현 없이 명세만 정의한 것** |

# 핵심 내용

책을 읽다 보면, 특히 후반부로 갈수록 앞에서 말한 내용을 대상만 바꿔서 계속 반복한다는 느낌을 준다.

3부까지는 프로그래밍 패러다임 및 SOLID 원칙에 대한 이론적 설명이라 새로운 내용이 나오는데, 이후부터는 앞서 배운 이론을 여러 대상에 반복해서 적용하는 구조로 이루어져서, 비슷한 논의가 반복되는 느낌이었다.

클린 아키텍처에서 반복해서 강조하는 내용을 압축하면 아래 3가지로 정리할 수 있다.

## **1. 분리 (Separation): 중요한 것과 중요하지 않은 것을 분리하기**

소프트웨어에는 두 가지 종류의 코드가 있다.

• **정책 (Policy):** 업무 규칙, 비즈니스 로직, 시스템의 존재 이유. (변하지 않거나 드물게 변함)

• **세부사항 (Detail):** 데이터베이스, 웹 프레임워크, UI, 입출력 장치. (자주 변함)

아키텍처는 정책이 세부사항에 대해 전혀 모르게(의존하지 않게) 만드는 기술이다.

이유는 **변경의 파급 효과를 막기 위해서다.** 세부사항은 유행에 따라, 혹은 기획 변경에 따라 수시로 바뀐다. 만약 두 영역이 섞여 있다면, UI 버튼 하나를 수정하거나 DB를 교체하는 사소한 작업 중에 핵심 비즈니스 로직까지 망가질 위험이 생긴다.

## **2. 방향 (Direction): 의존성은 한쪽으로만 흐른다**

소스 코드 의존성은 반드시 **바깥쪽(저수준/세부사항)에서 안쪽(고수준/정책)으로** 향해야 한다.

> $세부사항(Low) \rightarrow 정책(High)$
> 
- **저수준(Low Level):** 세부사항과 관련된 코드(UI/프레임워크/데이터베이스). 데이터가 실제로 어떻게 저장되고, 화면에 어떻게 픽셀로 그려지는지와 같은 **구체적인 작동 방식**을 다룸
- **고수준(High Level):** 화면과 디자인에 종속되지 않는 **절대 변하지 않는 계산 규칙**. 상위 수준의 개념과 규칙을 다루며, 시스템의 **본질적인 가치**를 담고 있음

저수준 코드는 고수준 코드를 알아야 하며, 고수준은 저수준을 절대로 몰라야 한다.

예를 들어 덧셈을 하고 그 결과를 저장하는 계산기 서비스를 만든다고 했을 때,

다음 파일 `Calculator.ts`은 고수준이다.

```tsx
// ✅ 순수 비즈니스 로직 (React, HTML 모름)
export class Calculator {
  add(a: number, b: number): number {
    if (a < 0 || b < 0) throw new Error("음수는 안돼요"); // 업무 규칙
    return a + b;
  }
}
```

이를 활용하는 `App.tsx` 리액트 코드는 저수준이다. (UI)

```tsx
import { useState } from 'react';
import { Calculator } from './Calculator'; // 방향: UI가 로직을 import 함

// ✅ UI는 로직을 가져다 쓰기만 함 (세부사항 -> 정책)
const App = () => {
  const calc = new Calculator(); // 도구 생성
  const [result, setResult] = useState(0);

  const handleClick = () => {
    // UI가 입력을 받아 고수준 로직에게 토스
    const value = calc.add(10, 20); 
    setResult(value);
  };

  return <button onClick={handleClick}>{result}</button>;
};
```

이 때 `App.tsx`(저수준)는 `Calculator.ts`(고수준)를 알지만 `Calculator.ts`는 자신이 리액트에서 쓰이는지 HTML에서 쓰이는지 모른다. 이것이 올바른 의존성 방향이다.

이렇게 사용하는 이유는 **보호하기 위해서다.** 건축물로 치면 '정책'은 건물의 뼈대이고, '세부사항'은 벽지나 인테리어다. 벽지를 바꾼다고 기둥이 흔들려서는 안 된다. 변하기 쉬운 것이 변하지 않는 것에 의존해야 시스템이 안정적으로 유지된다.

## 3. 도구 (Mechanism): 의존성 역전 원칙과 다형성

개발을 하다 보면 정책(고수준 코드)이 세부사항(저수준 코드)을 호출해야 하는 경우가 생긴다.

ex) 위 계산기 예시에서 계산 결과를 localStorage에 저장해 달라는 요구사항이 생기면?

```tsx
// Calculator.ts
export class Calculator {
  add(a: number, b: number) {
    const result = a + b;
    // 😱 고수준이 저수준(브라우저)을 알게 됨.
    // 이제 이 코드는 Node.js나 앱에서 못 씀.
    localStorage.setItem('result', result.toString()); 
    return result;
  }
}
```

위와 같이 구현하면 의존성 규칙을 위반하게 된다.

이처럼 실행 흐름은 `정책 -> 세부사항`인데, 의존성 규칙은 `세부사항 -> 정책`이어야 하는 모순이 발생한다.

이 모순을 해결하는 도구가 **인터페이스를 통한 의존성 역전**이다.

### **세부적인 설명 (메커니즘)**

1. **인터페이스 정의:** 정책(고수준) 계층은 자신이 필요한 기능을 인터페이스로 정의한다.
    
    ```tsx
    // [고수준 영역]
    
    // 1️⃣ 인터페이스 정의 (계약서)
    export interface SaveStorage {
      save(data: number): void;
    }
    
    export class Calculator {
      // 2️⃣ 생성자를 통해 저장해주는 서비스를 받음 (누군진 모름)
      constructor(private storage: SaveStorage) {}
    
      add(a: number, b: number) {
        const result = a + b;
        this.storage.save(result); // 3️⃣ 인터페이스한테 명령만 내림
        return result;
      }
    }
    ```
    
2. **구현체 생성:** 세부사항(저수준) 계층은 그 인터페이스를 구현(Implements)한다.
    
    ```tsx
    // [저수준 영역]
    import { SaveStorage } from './Calculator';
    
    // 4️⃣ 실제 구현 (Browser API 사용)
    export class LocalStorageSaver implements SaveStorage {
      save(data: number) {
        console.log("브라우저에 저장:", data);
        localStorage.setItem('calc_result', data.toString());
      }
    }
    ```
    
3. **조립:** 상위 코드에서 둘을 연결한다.
    
    ```tsx
    // [가장 바깥쪽 - 저수준 설정 영역]
    const App = () => {
      // 5️⃣ 여기서 '저장소'를 갈아끼울 수 있음!
      // 만약 서버에 저장하고 싶으면 'ApiSaver'로 바꾸기만 하면 됨.
      const saver = new LocalStorageSaver(); 
      const calc = new Calculator(saver); 
    
      return <button onClick={() => calc.add(1, 2)}>Calc</button>;
    };
    ```
    

결과적으로, 제어 흐름은 `정책 -> 세부사항`으로 흐르지만, 소스 코드 의존성은 `세부사항 -> 정책`으로 역전되어(의존성 역전), 정책은 세부사항의 구체적인 존재(DB가 무엇인지 등)를 전혀 모르는 상태로 기능을 수행할 수 있게 된다. 이를 통해 시스템은 완벽한 **플러그인 아키텍처**를 갖추게 된다.

# 감상

한번쯤 읽어보기 좋은 책이라고 생각한다.

이 책을 읽기 전에는 코드를 분리할 때 ‘가독성’이라는 주관적인 지표를 중시했었다. 예를 들면 분리의 기준을 컴포넌트 하나가 200줄을 넘긴다든지, 함수 하나가 너무 길어진다든지 하는 복잡성을 바탕으로 결정했다.

그런데 코드 분리가 가독성에 항상 도움이 되는 것도 아니고(너무 쪼개면 오히려 타고 들어가야 해서 더 읽기 힘들어지는 경우가 있었다), 가독성 자체가 주관적인 지표이다보니… 뭔가 이 기준으로 코드를 분리하는 게 정답이 아닌 것 같은데 그럼 뭘 기준으로 분리해야 하는지 모르겠는 상황이 왔었다.

예를 들면, 컨텍스트를 커스텀 훅으로 감싸는 다음과 같은 코드 패턴은 많이 사용되는 편이다.

```tsx
const useUser = useContext(UserContext);
```

난 처음 이 패턴을 봤을 때 가독성 측면에서 파악하기 쉽게 하려고(혹은 쓰는 입장에서 손쉽게 타이핑하려고) 코드를 간소화한 패턴이라고 생각했다.

하지만 사실 저 코드가 그렇게 읽기 어려운 건 아니다. useContext(UserContext)가 useUser에 비해 잘 안 읽히는 건 사실이지만, 오히려 이 useUser가 그래서 내부적으로 어떤 상태관리를 사용하는데? 를 알고 싶은 사람에게는 한 번 타고 들어가야 하는 번거로움이 더 크게 느껴질 수 있다. 즉 가독성이라는 건 어디까지나 상대적이라는 말이다.

그렇다면 어째서 저 패턴을 그렇게 많이 쓰는 걸까?

책을 읽고 나서야 알게 되었다. 저렇게 커스텀 훅으로 감싸는 패턴의 가장 큰 이유는 **컨텍스트라는 세부사항을 겉으로 드러내지 않기 위한 인터페이스**였다.

예를 들면 useUser가 지금은 useContext로 정의되지만, Zustand로 바뀔 수도 있고, 로컬스토리지가 될 수도 있다. useContext를 직접 썼더라면 이런 변경사항이 생길 때 모든 구현부를 바꿔야 하지만, 커스텀 훅으로 전파했다면 훅을 정의한 부분만 바꾸면 된다.

코드를 분리하는 이유도, 아 이렇게 하면 읽기 쉬울 것 같은데? 같은 주관적인 판단에만 있는 것이 아니라,

‘저수준과 고수준을 분리하면 나중에 저수준을 빨리 교체할 수 있겠다’ 같은 **효율 중심적인 이유**도 가능하다는 점을 알게 되었다.

이러한 판단은 가독성을 기반으로 한 결정보다 이견이 적을 것 같다.

저자는 45년동안 프로그래밍을 하면서 수없이 많은 저수준 변화들을 겪었을 것이다.

나는 아직 경력이 짧아서 그런 변화를 체감할 만한 경험이 많지 않다.

그래서 개발을 하면서도 이런 변경의 용이함이라는 관점을 크게 생각해내지 못했는데, 이 책을 통해 저자의 오랜 경험에서 나온 지혜를 엿볼 수 있어서 좋았다.

# 스터디에 대한 회고

사실 이 책은 친한 개발자 친구랑 완독 스터디를 열어서 읽었다.

정석적으로 한다면 원래 매주 정해진 분량을 서로 읽고 각자 정리하고 토론 시간을 가지는 식으로 진행하면서 만약 누군가 정리를 빼먹었다면 벌금을 무는 식으로 진행했을 것이다. 하지만 이번 스터디는 굉장히 프리하게 요약정리 의무도, 벌금제 같은 페널티도 없었다. 매주 토요일까지 정해진 분량을 읽고 토론하는 시스템만 유지했다.

그렇게 된 배경에는 일단, 같이 하는 친구가 책 스터디의 요약 정리 시스템에 대해 회의감을 갖고 있었다. 책을 다 읽고 내용 정리를 하는 게 아니라, 내용 정리를 만들면서 읽는 형태가 되어버려서 오히려 책을 이해하기 어려워지고 의미를 알기 힘들다고 했다. 어느 정도는 공감했다.

페널티의 경우, 친구가 직장과 대학을 병행하는 중이라 바빠질 수 있는 상태여서 스트레스를 주고 싶지 않았고 조금은 널널하게 진행하기 위해서 없앴다.

그래서 상당히 프리한 스터디를 했고… 결과는?

친구는 4부까지 읽고 바빠져 더 읽지 못했고… 나는 원래 12주로 계획되었던 것을 밀리고 밀려서 18주만에 꾸역꾸역 읽을 수 있었다.

**깨달은 점** :

- 역시 페널티는 필요하다. 그게 없으면 밀리게 된다.
- 요약정리는, 확실히 정리 의무가 없으니 부담 없이 읽을 수 있다는 장점이 있었다. 다만 요약정리를 진행했던 예전의 스터디들에 비해 지식이 촘촘하게 박히지 못하는 느낌이었다.
    
    또 보통 스터디에서 요약정리가 필요한 이유는 이 사람이 실제로 읽었는지 읽지 않았는지 검증하기 위해서이기도 해서, 이렇게 믿을 수 있는 친한 친구랑 하는 게 아니라면(그리고 페널티가 있다면) 정리는 들어갈 수밖에 없을 것 같다.
    
    다만, 굳이 책의 모든 내용을 완벽하게 정리할 필요는 없을 것 같다. 그냥 해당 섹션을 읽으면서 새롭게 느낀 점, 알게 된 점만 정리해도 중요한 내용은 충분히 머리에 들어오지 않을까 싶다.
