# HTTP 캐싱이란?

요청과 관련된 응답을 저장하고, 이후 요청에 대해 저장된 응답을 재사용하는 기술.

웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면 그 문서는 원 서버가 아니라 캐시로부터 제공된다.

# 캐시의 장점

1. **응답 속도 향상** : 원본 서버로 요청을 보낼 필요가 없어 클라이언트와 캐시가 가까울수록 응답이 빨라진다.
2. **서버 부하 감소** : 응답 재사용 시 원본 서버는 요청을 처리할 필요가 없어 요청 파싱, 라우팅, DB 쿼리 등의 작업이 줄어든다. 이는 서버의 부하를 감소시킨다.
3. **네트워크 비용 감소** : 여러 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송한다. 그러나 캐시를 이용하면 첫 번째 서버 응답이 캐시에 보관되어 뒤이은 요청들에는 캐시된 사본이 응답으로 사용되므로 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어든다.

# 캐시의 종류

HTTP 캐싱 사양에는 **사설 캐시(private caches)**와 **공유 캐시(shared caches)**의 두 가지 주요 캐시 유형이 있다.

## 사설 캐시

1. **정의** : 특정 사용자 전용 캐시. 한 명에게만 할당된 캐시이다.
2. **예시** : 브라우저 캐시(웹 브라우저가 사용하는 캐시. 사용자 단말기의 로컬 디스크 혹은 메모리에 저장됨)
3. **특징** :
    - 저장된 응답이 다른 클라이언트와 공유되지 않으므로, 해당 사용자를 위한 **개인화된 응답**을 저장할 수 있다.
        
        (만약 응답에 개인화된 콘텐츠가 포함되어 있고, 해당 응답을 사설 캐시에만 저장하려면 HTTP의 Cache-Control 헤더에 `private` 지시어를 명시해야 한다.)
        

## 공유 캐시

공유 캐시는 클라이언트와 서버 사이에 위치하며, 사용자 간에 공유될 수 있는 응답을 저장한다. 공유 캐시는 다시 **프록시 캐시**와 **관리형 캐시**로 세분화된다.

### 프록시 캐시

1. **정의** : 클라이언트와 서버 사이의 **중간 서버(프록시)**가 응답을 저장해 두었다가, 동일하거나 유사한 요청이 오면 원 서버에 가지 않고 **자신의 캐시에 저장된 응답을 반환**하는 캐시.
2. **예시** :
    - **ISP 캐시** : 인터넷 서비스 제공자가 운영. 같은 지역 사용자들의 반복 요청(예: 인기 이미지/동영상)을 캐싱하여 대역폭 절약.
    - **기업/학교 프록시 캐시** : 조직 내부 네트워크 관리자가 운영. 내부 사용자들의 웹 요청을 캐싱하여 트래픽 절감, 응답 속도 향상, 접근 제어 및 로깅 가능.
    - **TLS 브리지 프록시(엔터프라이즈 환경)** : 기업이 사용자 PC에 자체 CA 인증서를 설치해 HTTPS 트래픽을 복호화/검사하며 캐싱하는 방식.
3. **특징** :
    - 저장 위치는 **프록시 서버의 디스크/메모리**이며, 여러 사용자가 공유한다.
    - 캐싱 여부와 정책은 **프록시 운영자(조직, ISP, 기업 네트워크 관리자)**가 제어한다.
    - 최근에는 HTTPS가 보편화되면서 중간 프록시는 응답 내용을 볼 수 없어 **캐시 역할을 하기 어려워졌다**. 대부분의 경우 단순히 트래픽을 터널링하는 수준이며, 프록시 캐시의 영향력은 줄어들었다. 다만 기업 내부 네트워크(엔터프라이즈 환경)에서는 여전히 TLS 브리지 프록시를 통해 캐시가 동작할 수 있다.

### 관리형 캐시

1. **정의** : 서비스 개발자가 원본 서버의 부하를 줄이고 콘텐츠를 효율적으로 전달하기 위해 명시적으로 배포하는 캐시
2. **예시**: 리버스 프록시, CDN, Cache API와 결합된 서비스 워커 등
3. **특징**:
    - 배포된 제품에 따라 관리형 캐시의 특성이 다르지만, 대부분의 경우 `Cache-Control` 헤더와 자체 구성 파일 또는 대시보드를 통해 캐시 동작을 제어할 수 있다.
    - HTTP 캐싱 사양은 캐시를 명시적으로 삭제하는 방법을 정의하지 않지만, 관리형 캐시를 사용하면 대시보드 작업, API 호출, 재시작 등을 통해 저장된 응답을 언제든지 삭제할 수 있어 보다 **능동적인 캐싱 전략**이 가능하다.
    - 표준 HTTP 캐싱 사양 프로토콜을 무시하고 명시적인 조작을 수행하는 것도 가능하다. 예를 들어, `no-store` 지시어를 사용하여 사설 캐시 또는 프록시 캐시를 옵트아웃하면서, 자체 전략을 사용하여 관리형 캐시에만 캐시할 수 있다.
    - 일부 CDN은 해당 CDN에만 유효한 자체 헤더(예: `Surrogate-Control`)를 제공한다. 현재 이러한 헤더를 표준화하기 위한 `CDN-Cache-Control` 헤더 정의 작업이 진행 중이다.

# 캐시의 동작

## 휴리스틱 캐싱

HTTP는 가능한 한 많이 캐시하도록 설계되었으므로, `Cache-Control`이 주어지지 않아도 특정 조건이 충족되면 응답이 저장되고 재사용된다. 이를 **휴리스틱 캐싱**이라고 한다.

ex) 1년 전에 마지막으로 업데이트된 응답의 경우, 1년 동안 업데이트되지 않은 콘텐츠는 그 이후에도 한동안 업데이트되지 않을 것이라고 판단하고 클라이언트는 이 응답을 저장하고 한동안 재사용함

(재사용 기간은 구현에 따라 다르지만, HTTP 명세에서는 수정되지 않은 기간의 10%(이 경우 0.1년)를 캐싱 시간으로 삼기를 권장)

이는 브라우저나 프록시 구현마다 다르게 동작할 수 있으므로, 현대 웹 개발에서는 **반드시 Cache-Control 헤더를 명시적으로 지정해야 한다.**

## Age 개념

응답이 생성된 시점부터 현재까지 지난 시간. `Cache-Control: max-age=N` 헤더와 비교해서 신선한지(fresh) 오래되었는지(stale)를 판정한다.

- `Age < max-age` → fresh
- `Age ≥ max-age` → stale

예시)

```jsx
HTTP/1.1 200 OK
Date: Tue, 22 Feb 2022 22:22:22 GMT
Cache-Control: max-age=604800   # 604800초 = 7일
```

- 캐시에 저장된 순간부터 7일 동안은 fresh 상태.
- 7일이 지나면 stale 상태가 됨.

공유 캐시(CDN, 프록시 캐시 등)는 응답을 저장한 뒤에도 다른 클라이언트 요청에 재사용할 수 있음.

이때 클라이언트가 응답을 받았을 때 **응답이 실제로 얼마나 오래된 것인지** 알려주기 위해 `Age` 헤더를 추가할 수 있음

```jsx
Cache-Control: max-age=604800   # 7일
Age: 86400                     # 1일이 지남
```

→ 클라이언트 입장에서 계산:

- 전체 만료 시간 = 604800초
- 이미 경과한 시간 = 86400초 (1일)
- 남은 유효 시간 = 604800 - 86400 = 518400초 (6일)

즉, 이 응답은 앞으로 6일 동안 fresh로 취급 가능.

# 캐시 제어 방법

캐시는 `Cache-Control` 헤더 필드를 통해 제어하며, 여러 디렉티브를 콤마(,)로 구분해서 동시에 쓸 수 있다.

Cache-Control에 쓰이는 디렉티브는 다음과 같다.

- `no-store` : 캐시에 응답이 저장되지 않게 함.
    
    no-store 사용 시 브라우저의 뒤로/앞으로 캐시를 포함하여 HTTP와 브라우저가 제공하는 많은 이점을 잃게 되므로 해당 디렉티브는 권장되지 않으며 no-cache와 private의 조합이 권장된다.
    
- `no-cache` : 캐시에 저장을 허용하되, 응답을 제공할 때 항상 서버에서 재검사를 하게 한다.
- `must-revalidate` : 캐시가 신선하지 않은 사본을 재검사 없이 제공해서는 안 됨을 의미한다.
    
    캐시는 성능을 개선하기 위해 신선하지 않은 객체를 제공하도록 설정될 수 있으나, must-revalidate가 있으면 stale 응답을 절대 보여주지 않는다.
    
- `max-age` : 신선하다고 간주되는 문서의 나이.
- `private` : 응답이 특정 클라이언트에만 저장되고 캐시의 다른 사용자에게 유출되지 않음. 개인화된 콘텐츠가 포함된 응답에 유용하다.

이외에도, 이전에는 `Expires: <date>` 헤더를 통해 캐시의 신선함을 계산하기도 했으나 이는 deprecated되고 max-age로 대체되었다.

⇒ 시간 형식이 파싱하기 어렵고, 구현 버그가 많으며 시스템 시계를 의도적으로 조작하여 문제를 유발할 수 있기 때문에 절대시각 대신 경과된 시간으로 만료를 표현하게끔 대체되었다.

# Vary 헤더

응답은 기본적으로 요청 URL(스킴 + 호스트 + 경로 + 쿼리스트링)을 키로 삼아 구별하는데, 동일 URL이어도 서버의 응답은 `Accept`, `Accept-Language`, `Accept-Encoding` 요청 헤더 값에 따라 달라질 수 있다.

ex) `Accept-Language: en` 헤더로 요청된 영어 컨텐츠와 `Accept-Language: ja` 헤더를 가진 요청의 응답값은 달라짐

이 경우 `Vary` 헤더 값에 `Accept-Language`를 추가하여 언어에 따라 응답이 별도로 캐시되도록 할 수 있다.

```jsx
Vary: Accept-Language
```

이는 캐시가 응답 URL뿐만 아니라 `Accept-Language` 요청 헤더의 조합을 기반으로 키를 생성하도록 한다.

# 유효성 검사

오래된 응답은 즉시 폐기되지 않는다. HTTP는 원본 서버에 요청하여 오래된 응답을 신선한 응답으로 변환하는 메커니즘을 가지고 있는데, 이를 **유효성 검사(validation)** 또는 **재유효성 검사(revalidation)**라고 한다.

유효성 검사는 `If-Modified-Since` 또는 `If-None-Match` 요청 헤더를 포함하는 **조건부 요청(conditional request)**을 사용하여 수행된다.

### If-Modified-Since

1. **작동 방식**:
    1. `max-age`가 1시간인 응답은 22:22:22에 생성되어 23:22:22까지 신선하다.
    2. 23:22:22에 응답이 오래되어 캐시를 재사용할 수 없게 되면, 클라이언트는 `If-Modified-Since` 요청 헤더를 포함하여 지정된 시간 이후 변경 사항이 있는지 서버에 묻는 요청을 보낸다.
    3. 콘텐츠가 지정된 시간 이후 변경되지 않았다면 서버는 `304 Not Modified`로 응답한다.
    4. 이 응답은 "변경 없음"만 나타내므로 응답 본문이 없고 상태 코드만 있어 전송 크기가 매우 작다.
    5. 이 응답을 받으면 클라이언트는 저장된 오래된 응답을 다시 신선한 상태로 되돌리고 남은 1시간 동안 재사용할 수 있다.
2. **장점**: 서버는 운영체제 파일 시스템에서 수정 시간을 얻을 수 있어 정적 파일을 제공하는 경우 비교적 쉽다.
3. **문제점**: 시간 형식이 복잡하고 파싱하기 어려우며, 분산 서버는 파일 업데이트 시간 동기화에 어려움이 있다.
4. **대안**: 이러한 문제를 해결하기 위해 `ETag` 응답 헤더가 대안으로 표준화되었다.

### ETag

**Entity Tag**의 줄임말. 서버가 리소스(HTML, CSS, 이미지 등)에 대해 발행하는 **고유 식별자**이다.

생성 방식에 제약이 없으므로, 콘텐츠 본문을 해싱한 값 (예: md5, sha1 등)이나 버전 번호 등 어떤 수단으로든 값을 자유롭게 설정할 수 있다.

1. **작동 방식**:
    1. `index.html` 리소스의 해시 값이 `"33a64df5"`인 경우, 응답은 다음과 같다.
        
        ```jsx
        HTTP/1.1 200 OK
                Content-Type: text/html
                Content-Length: 1024
                Date: Tue, 22 Feb 2022 22:22:22 GMT
                ETag: "33a64df5"
                Cache-Control: max-age=3600
                 …
        ```
        
    2. 이 응답이 오래되면 클라이언트는 캐시된 응답의 `ETag` 응답 헤더 값을 가져와 `If-None-Match` 요청 헤더에 넣어 리소스가 수정되었는지 서버에 묻는다.
    3. 요청된 리소스의 `ETag` 헤더 값이 요청의 `If-None-Match` 값과 동일하면 서버는 `304 Not Modified`를 반환한다.
    4. 그러나 요청된 리소스의 `ETag`와 `If-None-Match` 값이 다르면 서버는 `200 OK`와 리소스의 최신 버전을 내려준다.
2. **장점** : Last-Modified가 마지막 수정 시간 기반으로 초 단위 정밀도와 분산 서버 시간 불일치 문제가 있던 것과 다르게 ETag는 콘텐츠 자체의 식별자 기반으로 더 정밀하고 안정적이다.

RFC9110에서는 ETag와 Last-Modified를 모두 제공하는 것을 권장한다.

- `Last-Modified`는 캐싱뿐만 아니라 콘텐츠 관리(CMS) 시스템에서 최종 수정 시간을 표시하거나, 크롤러가 크롤링 빈도를 조정하는 등 다양한 목적으로 사용되는 표준 HTTP 헤더이다.
- 캐시 재유효성 검사 중 `If-Modified-Since`와 `If-None-Match`가 모두 존재하면 `If-None-Match`가 유효성 검사기에서 우선한다.

# 출처

https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Caching
