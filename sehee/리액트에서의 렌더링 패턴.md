# CSR이란?

클라이언트 사이드 렌더링. 렌더링을 클라이언트(브라우저)에 위임하여 렌더링 로직을 클라이언트에서 수행하는 방식으로, 서버는 최소한의 HTML만 내려주고 클라이언트 측에서 해당 HTML과 CSS, JS 등을 파싱하여 화면을 렌더링한다.

CSR은 기본적으로 SPA(Single Page Application)이기도 하다.

## CSR의 장점

- 뷰가 그려지는 시점과 인터랙션이 가능한 시점이 동일해서 사용자에게 상호작용이 빠르게 느껴짐
- 직관적, DX좋음, 생성 및 관리가 간단함
- 페이지 이동 속도가 빠름(SPA에서 딸려오는 장점)

## CSR의 단점

### 1. CSR 앱의 콘텐츠를 불러오려면 JS 실행이 필요하므로 SEO에 불리

요즘 크롤러들은 JS를 실행할 수 있는 방향으로 발전하고는 있으나, 모든 크롤러가 JS 실행을 지원하는 것은 아니므로 불리한 것은 사실

### 2. 데이터 페칭을 위한 네트워크 왕복

데이터 로딩이 포함된 앱의 경우 데이터 페칭 로직을 위해 서버를 한번 더 왕복해야 하므로 필연적으로 로딩 지연이 생긴다.

대부분의 데이터 기반 애플리케이션에서 주요 콘텐츠는 데이터 페칭을 필요로 하므로, 이는 느린 LCP(페이지에서 가장 큰 UI가 렌더링되는 시점)를 초래한다.

### 3. 초기 로딩 속도가 김

최초 진입시 페이지를 구성할 JS를 받아오고 파싱해야 하므로 빈 화면 문제가 발생할 수 있다.

이를 해결하기 위해서는 레이지 로딩이나 번들 크기 관리, 코드 스플리팅 등의 기법이 필요하다.

### 4. 클라이언트에 따라 부각되는 성능 이슈

렌더링을 위한 모든 작업을 클라이언트에 위임하기 때문에, 클라이언트가 느린 기기나 네트워크를 갖고 있을 경우 특히 성능이 좋지 않다.

# SSR이란?

서버 사이드 렌더링. 서버에서 UI 렌더링 로직을 실행해 완성된 HTML을 내려주는 방식

## SSR의 장점

- SEO(Search Engine Optimization)에 유리함
- 데이터 페칭을 돌린 이후의 완성된 UI를 바로 받기 때문에 사용자가 중요한 콘텐츠를 볼 수 있는 시점(LCP)이 CSR보다 빠름
- 느린 클라이언트 기기들에서 더 나은 성능을 보임

## SSR의 단점

- 서버가 모든 컴포넌트의 렌더링을 끝내고 HTML을 완성한 이후에야 데이터를 클라이언트에 전송할 수 있기 때문에 느린 컴포넌트가 포함되어 있을 경우 서버에서의 블로킹이 생기고, 화면에 표시되는 시간이 느려짐(느린 TTFB - 첫 번째 바이트가 오는 시간)
    
    ex) 한 페이지 안에 5초의 렌더링 시간이 걸리는 느린 컴포넌트가 있다면, 해당 컴포넌트를 포함한 페이지는 5초동안 아무것도 표시하지 않음(모든 컴포넌트의 서버 렌더링이 완료된 이후에야 완성된 HTML을 내려보낼 수 있음)
    
    ⇒ Streaming SSR이라는 방식으로 보완
    
- 리액트의 경우, SSR로 렌더링하더라도 추후 상호작용을 위해서는 클라이언트 단에서 Virtual DOM 생성이 필요하고, 이를 위한 리액트 코드 및 컴포넌트 다운로드&실행이 클라이언트에서 필요함 ⇒ 비효율, 성능비용 증가
    
    ⇒ RSC로 보완
    
- 상호작용을 위해서는 자바스크립트 다운로드와 하이드레이션 과정이 필요하므로, 사용자 입력에 반응 가능한 시점(TTI)과 컨텐츠가 화면에 보여지는 시점(FCP) 사이에 간극이 존재하고 이로 인해 사용자 불편을 유발할 수 있음
- 서버에서 렌더링된 HTML과 클라이언트 컴포넌트 간의 불일치가 있을 때(ex: 타임스탬프, 랜덤 숫자) 하이드레이션 과정에서 에러가 나 컴포넌트가 제대로 동작하지 않을 수 있음

# Streaming SSR

블로킹 이슈를 해결하기 위해 고안됨.

서버에서 렌더링이 완료된 컴포넌트를 부분 스트리밍하여 빠른 TTFB를 보장하는 기법

리액트에서는 이를 지원하는 `renderToPipeableStream()` 가 React 18부터 등장했고, 스트림이 클라이언트에 도착하기 전에 화면을 로딩 폴백으로 채워줄 수 있는 `Suspense` 와 함께 사용되며 기존의 느린 로딩 문제를 해결함

(ex: 한 페이지 안에 각각 1초, 3초, 5초의 렌더링 시간이 걸리는 컴포넌트가 있을 경우, 해당 컴포넌트들을 감싸는 Suspense로 인해 최초에 로딩 폴백이 그려지고, 이후 컴포넌트들의 렌더링이 완료될 때마다 페이지에 순차적으로 그려짐)

# React Server Component

리액트에서의 높은 하이드레이션 비용을 해결하기 위해 고안됨

## React에서의 SSR 문제

전통적인 리액트에서의 SSR은 다음과 같은 과정을 거침

1. 서버가 전체 앱을 HTML로 렌더링함(`renderToString(<App />)`)
2. 클라이언트가 HTML을 받음
3. 클라이언트에서 React 라이브러리 및 전체 컴포넌트 코드 다운로드
4. 클라이언트에서 리액트 내부적으로 작동하는 가상돔 트리를 만들기 위해 App 컴포넌트를 실행
5. 만들어진 가상돔 트리를 HTML DOM과 연결하기 위한 작업 진행(하이드레이션)
    1. React가 가상돔과 HTML로 만들어진 실제 돔을 병렬로 탐색
    2. 실제 HTML 돔 노드와 매치되는 가상돔 노드를 찾음
    3. 실제 돔 노드에 이벤트 핸들러 부착
    4. 상태관리 셋업

이 과정은 비효율적인 동작이 많으며, 전체적으로 JS를 다운로드받고 실행하는 비용이 큼

- 서버는 최초에 전체 앱을 렌더링하는데, 클라이언트에서도 Hydration을 위해 전체 앱 코드를 내부적으로 실행함(서버, 클라이언트 이중 렌더링 및 번들 크기 증가)
- 리렌더링 가능성이 없는 정적인 컴포넌트에서도 혹시 모를 변경사항을 위해 가상돔을 만들고 실제 돔 요소와 매치하는 불필요한 과정이 있음

> Q. 어째서 페이지 단위로 코드를 다운/실행하지 않고 전체 애플리케이션을 렌더링할까?
>
> A. React에서 하위 트리만 따로 렌더링하면 상위 컨텍스트에 동적인 요소가 있을 경우(ex: Context Provider) 이것이 손실되어 리렌더링 시 제대로 작동하지 않을 수 있으며, 일관성이 보장되기 어려움.
> 

> Q. 그냥 서버에서 가상돔 트리까지 다 만들어서 넘겨주면 안되나?
>
> A. 가상돔에 필요한 Fiber 구조는 순수 데이터가 아닌 컴포넌트 함수, 프로미스 객체 등 직렬화 불가능한 값이 포함되어 서버→클라이언트 전송이 불가하므로 이 접근은 어려움.
> 

## RSC의 해결 방법

클라이언트에서의 가상돔 생성이 필요 없는 static한 컴포넌트(업데이트되지 않는 컴포넌트)와 상호작용이 필요한 컴포넌트를 구분하고, 상호작용이 필요한 컴포넌트를 바운더리로 나눈 후 이 부분에만 하이드레이션을 적용하는 기법

이때 static한 컴포넌트가 리액트 서버 컴포넌트이며, 상호작용이 필요한 컴포넌트가 클라이언트 컴포넌트임(use client 디렉티브가 적용된 컴포넌트)

**서버 컴포넌트는 컴포넌트 코드를 번들링에 포함시키지 않고** 렌더링 결과물을 내려줌, 이 때 클라이언트 컴포넌트의 자리는 placeholder로 대체하여 표현되고, 렌더링 결과물과 함께 전송되는 RSC payload라고 하는 데이터에 각 자리에 들어갈 클라이언트 컴포넌트의 참조를 표기

클라이언트 단에서는 RSC payload를 보고 클라이언트 컴포넌트 코드를 다운로드하여 실행, 하이드레이션하여 VDOM 생성

이를 통해, 불필요한 인터랙션 대비를 제거하여 **클라이언트에서 다운로드 및 실행되는 컴포넌트를 최소한으로 줄임**

## RSC의 장점

- **번들 크기 축소** : 서버 구성 요소는 JS 번들에 포함되지 않으므로 다운로드해야 하는 JavaScript의 양과 하이드레이션해야 하는 구성 요소의 수가 줄어듦
- **백엔드 코드에 대한 접근 향상** : 서버 컴포넌트를 사용하면 컴포넌트 트리의 어디에서든 백엔드 코드를 바로 호출할 수 있음. 전통적 SSR에서는 `getServerProps()`를 통해 백엔드 호출이 가능했으나, 이는 최상위 페이지에서만 가능했으므로 제한적임
- **자동 코드 분할** : 서버 컴포넌트는 클라이언트 컴포넌트의 모든 요소를 잠재적인 코드 분할 지점으로 처리하여 기본적으로 앱 제공을 최적화함
- 서버 컴포넌트는 점진적으로 렌더링되며, 렌더링된 UI 단위를 클라이언트로 증분 스트리밍하여 Suspense와 결합하면 중요한 콘텐츠를 빠르게 볼 수 있음
- 서버 컴포넌트는 다시 로드될 때 클라이언트 상태를 유지함

# 출처

https://tigerabrodi.blog/why-is-react-server-components-actually-beneficial-full-history

https://github.com/reactwg/react-18/discussions/37

https://github.com/reactjs/rfcs/blob/bf51f8755ddb38d92e23ad415fc4e3c02b95b331/text/0000-server-components.md

https://saengmotmi.netlify.app/react/what-is-rsc/

https://streaming-ssr-deep-dive.vercel.app/presenter/8

https://www.joshwcomeau.com/react/server-components/
