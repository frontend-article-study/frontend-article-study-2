## 프로토타입 개념은 **JS의 시작부터 있었다**

---

JavaScript는 1995년, 넷스케이프의 **브렌던 아이크(Brendan Eich)** 가 단 10일 만에 만든 언어예요.

그때부터 이미 **클래스(class)** 개념이 없었고, 대신 **프로토타입(prototype)** 기반의 상속을 사용했어요.

> 즉, 프로토타입은 JavaScript의 “후에 추가된 기능”이 아니라
> 
> 
> **언어의 근본적인 객체 모델**이에요.
> 
> (class는 2015년 ES6에서 나중에 추가된 “문법적 설탕”이에요.)
> 

## 왜 “프로토타입”을 선택했을까?

---

### 당시 상황 (1990년대 중반)

- 웹 브라우저 안에서 **가벼운 스크립트 언어**가 필요했어요.
- 브렌던 아이크는 JS를 **자바(Java)** 와 **스킴(Scheme)**, **셀프(Self)** 를 섞은 언어로 설계했어요.
- 여기서 **Self 언어**가 바로 “프로토타입 기반 객체지향”의 원조입니다.

### 프로토타입을 선택한 이유

| 이유 | 설명 |
| --- | --- |
| 🧩 **단순한 모델** | 클래스처럼 “청사진”을 정의할 필요 없이, **기존 객체를 복제(clone)** 해서 새 객체를 만들면 됨. |
| ⚙️ **유연한 런타임 구조** | 런타임 중에도 프로토타입을 바꾸거나 메서드를 추가/삭제 가능. (인터프리터 환경에 적합) |
| 💡 **함수 = 객체** | JS에서는 함수도 객체라서, 생성자 함수의 `prototype` 속성을 이용하면 **자연스럽게 상속 구조**를 표현할 수 있었음. |

즉, JS는 처음부터 **“Class-less OOP (클래스 없는 객체지향)”** 철학을 가졌던 거예요.

## “프로토타입” 이전에는 어떤방법을 사용했는 가?

---

### 🧭 1. JavaScript 이전의 주류 상속 방식: **클래스 기반 상속 (Classical Inheritance)**

### 대표 언어들

| 시대 | 언어 | 상속 방식 |
| --- | --- | --- |
| 1960s | Simula | “클래스” 개념 최초 도입 |
| 1970s | Smalltalk | 순수 객체지향, 클래스 계층 구조 확립 |
| 1980s | C++ | 클래스 + 타입 기반 상속 |
| 1990s | Java | 명시적 클래스 상속 (`extends`) |

### 클래스 기반 상속의 원리

클래스 기반 언어에서는 객체를 **“설계도(Class)”** 로 정의하고,

인스턴스는 그 설계도를 **복제(clone/copy)** 해서 생성합니다.

```java
class Animal {
    void move() { System.out.println("움직인다"); }
}

class Dog extends Animal {
    void bark() { System.out.println("멍멍"); }
}

Dog d = new Dog();
d.move(); // Animal의 메서드를 상속받음

```

즉, **Dog는 Animal의 복사본을 확장**하는 형태예요.

이 구조는 “컴파일 타임에 고정”되기 때문에 **정적 상속(static inheritance)** 이라고 부릅니다.

### 하지만 한계가 있었다

클래스 기반 상속은 강력하지만, 다음과 같은 제약이 있었습니다 👇

| 문제 | 설명 |
| --- | --- |
| ⚙️ 정적 구조 | 런타임 중에 클래스를 수정하거나 동적으로 확장하기 어려움 |
| 🧱 단일 계층 | “다중 상속”이나 “조합형 상속”이 복잡 |
| 🧩 설계 경직성 | 클래스 관계가 깊어질수록 코드 변경이 어렵고 결합도가 높아짐 |
| 🧠 실행 비용 | 객체마다 메서드를 개별 복사하면 메모리 낭비 발생 |

이런 문제들 때문에 1980년대 후반, 새로운 시도가 등장합니다.

### 프로토타입 기반 상속 의 등장 (1987년 — Self 언어)

- 1987년, **David Ungar** 와 **Randall Smith** 가 만든 **Self** 언어가 처음으로
    
    “프로토타입 기반 객체지향(prototypal OOP)”을 제안합니다.
    
- Self는 **클래스가 없고**, **객체 그 자체를 복제(clone)** 해서 새로운 객체를 만드는 모델을 사용했습니다.

```
copy := parent clone.
copy bark := [ '멍멍' print ].
copy bark.  "멍멍"
```

📌 핵심 철학

> “클래스는 불필요하다.
> 
> 
> 이미 존재하는 객체를 본보기(prototype)로 삼으면 충분하다.”
> 

➡️ 이 철학이 **JavaScript로 직접 이어집니다.**

브렌던 아이크는 JS를 만들 때 “Self + Scheme + Java 문법 느낌”을 결합했죠.

그래서 JS는 **Self 언어의 ‘프로토타입 상속’을 그대로 계승**했습니다.

**JS 이전의 상속 흐름**

| 시대 | 언어 | 상속 방식 | 특징 |
| --- | --- | --- | --- |
| 1960s | **Simula 67** | 클래스 기반 | 최초의 객체지향, 청사진 개념 등장 |
| 1970s | **Smalltalk** | 순수 클래스 기반 | 모든 것이 클래스, 메시지 기반 |
| 1980s | **C++, Java** | 정적 클래스 상속 | 강한 타입, 컴파일 타임 구조 |
| 1987 | **Self** | 프로토타입 기반 | 클래스 제거, 객체 복제 중심 |
| 1995 | **JavaScript** | Self 모델 계승 | 동적, 런타임 상속, 유연한 객체 구조 |

## 클래스 상속과 프로토타입

---

### 1) 철학과 모델의 차이

- **클래스 상속 (Classical)**
    - “설계도(클래스) → 인스턴스(객체)” 복제 중심.
    - 계층(트리) 구조가 선명하고 정적(컴파일 타임) 고정.
- **프로토타입 상속 (Prototypal / Delegation)**
    - “객체 → 객체” 참조 연결(위임) 중심.
    - 계층이 느슨하고 동적(런타임)으로 바꾸기 쉬움.

| 항목 | 클래스 상속 | 프로토타입 상속 |
| --- | --- | --- |
| 핵심 단위 | 클래스 | 객체 |
| 상속 원리 | 복사/확장 | 참조 위임(체인) |
| 시점 | 정적(컴파일) | 동적(런타임) |
| 구조 | 계층/트리 | 네트워크/사슬 |
| 변경 난도 | 높음 | 낮음 |

### 2) 메서드 저장·검색 방식 (Lookup)

- **클래스**: 인스턴스가 자신 타입의 vtable/메서드 테이블을 참조(언어/런타임마다 차이).
- **프로토타입**: `obj → [[Prototype]] → … → null`로 **체인 탐색**. 가장 먼저 발견된 속성이 승리(섀도잉).

```jsx
// 프로토타입 체인 예
const A = { x: 1 }
const B = Object.create(A)   // B.[[Prototype]] → A
B.y = 2
console.log(B.x) // 1 (A에서 위임)

```

### 3) ES6 class가 “Syntactic Sugar”인 이유 (JS 안에서는 결국 프로토타입)

```jsx
class Animal { move(){ console.log('move') } }
class Dog extends Animal { bark(){ console.log('bark') } }

```

위 코드는 내부적으로 대략 다음과 같은 **프로토타입 연결**로 풀립니다.

```jsx
function Animal(){}
Animal.prototype.move = function(){ console.log('move') }

function Dog(){}
Dog.prototype = Object.create(Animal.prototype)
Dog.prototype.constructor = Dog
Dog.prototype.bark = function(){ console.log('bark') }

```

> 결론: JS의 class/extends/super는 프로토타입 연결을 보기 좋게 감싼 문법이에요.
> 

---

### 4) 확장·변경의 유연성

- **클래스 상속**: 계층이 깊어질수록 변경 비용↑(상위 변경이 하위 전파).
- **프로토타입**: 런타임에 프로토타입 교체/주입 가능. 빠른 실험·핫패치에 유리.
    - 단, **무분별한 변경은 예측 가능성 저하**(팀 규약 필요).

```jsx
// 런타임에 메서드 주입
const p = { greet(){ console.log('hi') } }
const obj = Object.create(p)
p.greet = function(){ console.log('hello!') } // 체인 상 부모 수정
obj.greet() // hello!

```

---

### 5) 오버라이딩·슈퍼 호출

- **클래스**: `super.method()`로 명시.
- **프로토타입**: 체인 상 부모 메서드를 직접 호출(또는 `super` 키워드가 class 문맥에서만 제공).

```jsx
// 프로토타입 방식의 '슈퍼' 패턴
const base = { speak(){ console.log('base') } }
const child = Object.create(base)
child.speak = function(){
  base.speak.call(this)// 부모 호출
  console.log('child')
}
child.speak()
// base
// child

```

---

### 6) 다중 상속, 믹스인, 조합

- **클래스**: 전통적으로 단일 상속(다중 상속은 복잡성/다이아몬드 문제). 믹스인·트레이트로 보완.
- **프로토타입**: 여러 소스 객체를 **얕은 복사 + 위임**으로 섞기 쉬움(컴포지션 선호).

```jsx
// 믹스인(구성) 예
const canFly = { fly(){ console.log('fly') } }
const canSwim = { swim(){ console.log('swim') } }

const duck = Object.assign(Object.create({}), canFly, canSwim)
duck.fly(); duck.swim();

```

---

### 7) 메모리·성능 관점

- **공유 vs 사본**
    - 프로토타입에 메서드를 두면 **모든 인스턴스가 공유 → 메모리 절약**.
    - 인스턴스에 메서드를 넣으면 인스턴스마다 사본 → 메모리↑.
- **속성 접근 비용**
    - 체인이 길수록 조회 hop이 늘어날 수 있음. 보통 얕게 유지.
- **클래스 언어**: JIT/최적화(인라인 캐시, vtable 등)로 동적 비용을 상쇄. JS도 엔진이 IC/shape 최적화를 함 → **일관된 형태 유지**가 성능에 도움.

---

### 8) 테스트·설계 패턴과의 친화성

- **클래스 상속**: 전통적 OOP 패턴(템플릿 메서드, 팩토리, 전략)과 잘 맞음.
- **프로토타입**: **합성(Composition over Inheritance)**, **데코레이터**, **Behavior injection**과 궁합이 좋음. JS 생태계는 훅/함수형 조합도 흔함.

## 런타임? 컴파일 타임?

---

### 클래스 기반 언어의 상속 — “컴파일타임 구조 고정”

예: Java, C++, C#, Swift 등

```java
class Animal {
  void move() { System.out.println("move"); }
}
class Dog extends Animal {
  void bark() { System.out.println("bark"); }
}

```

**동작**

1. 코드를 **컴파일할 때**,
    
    컴파일러가 이미 “Dog는 Animal을 상속받는다”는 **클래스 계층 구조를 고정**시켜요.
    
2. 이후 실행 중에는 그 구조를 **바꿀 수 없습니다.**
    
    → “Dog의 부모를 Cat으로 바꾸기” 같은 건 불가능.
    
3. 즉, **상속 구조가 빌드타임(컴파일타임)에 결정**돼요.

📌 그래서 이걸 “정적 상속(static inheritance)”이라고도 부릅니다.

### 자바스크립트의 프로토타입 — “런타임에 연결, 변경 가능”

```jsx
const animal = { move() { console.log("move"); } };
const dog = Object.create(animal);
dog.bark = function() { console.log("bark"); };

dog.move(); // 'animal'의 메서드 사용

```

### 🔍 여기서는

1. `dog` 객체를 만들 때 `Object.create(animal)`을 **실행 중에** 호출합니다.
2. 이 시점(런타임)에 `dog`의 `[[Prototype]]`이 `animal`로 **연결**됩니다.
3. 실행 중에도 바꿀 수 있어요 👇
    
    ```jsx
    const cat = { meow(){ console.log("meow") } }
    Object.setPrototypeOf(dog, cat); // 런타임에 부모 교체
    dog.meow(); // 가능!
    
    ```
    

➡️ 즉, **상속 구조가 실행 중에도 바뀔 수 있다**

이게 바로 **런타임 상속**이에요.

### 요약

| 구분 | 클래스 상속 (정적) | 프로토타입 상속 (동적) |
| --- | --- | --- |
| 구조 결정 시점 | 빌드타임(컴파일 시) | 런타임(실행 시) |
| 변경 가능 여부 | 불가능 (고정) | 가능 (실행 중 연결 변경 가능) |
| 메모리 구성 | 고정된 클래스 레이아웃 | 객체 간 링크(참조) |
| 예시 언어 | Java, C++ | JavaScript |
| 비유 | 설계도 먼저 그리고 건물 짓기 | 블록을 실행 중에 조립하기 |

## JS에서는 가능하지만 클래스 기반에서는 불가능한 것

---

시점의 차이.

객체 정의 시점 : class -

객체 생성 시점 : new Class - 메모리화

### **JAVA**

```jsx
class Dog { int age; void bark() {} }
Dog d = new Dog();
d.color = "brown"; // ❌ 존재하지 않는 필드. 컴파일 에러.
```

“Dog 객체 = 4바이트짜리 age 필드 + 고정된 vtable 포인터”

구조가 **고정된 메모리 청사진**으로 저장됩니다.

데이터 구조 시각화

```jsx
+-------------------+
| Class Table (Dog) |  ← 컴파일 시 생성
|-------------------|
| Field: int age    |
| Method: bark()    |
| Method Table Ptr  |
+-------------------+

   ↓ new Dog()
+-------------------+
|  Object (Dog)     |
|-------------------|
| [age: 0]          |
| [vtable ptr → bark()] |
+-------------------+

```

### **JavaScript**

```jsx
const animal = { move() { console.log("움직인다"); } };
const dog = Object.create(animal);
dog.bark = () => console.log("멍멍");
```

JS에서는 **객체 자체가 클래스의 역할**을 합니다. 즉, “이 객체는 어떤 속성을 갖고, 어떤 걸 부모로 연결할지”를 런타임에 스스로 들고 있어요. 그 부모 링크가 바로 **`[[Prototype]]`** 입니다.

```jsx
   ┌──────────────┐
   │ Object: dog  │
   │--------------│
   │ name: "루비" │
   │ bark: fn()   │
   │ [[Prototype]] ──────────┐
   └──────────────┘          │
                             ▼
                     ┌──────────────┐
                     │ Object: animal│
                     │--------------│
                     │ move: fn()   │
                     │ [[Prototype]] → Object.prototype
                     └──────────────┘

```

## Hidden Class / Shape (V8 엔진 내부)

---

- JS 엔진은 객체의 구조를 추적하기 위해 **Hidden Class (Shape)** 를 내부적으로 유지합니다.
- 만약 객체 구조가 바뀌면 Hidden Class가 새로 만들어져요.

```
처음: { name } → Shape #1
나중: { name, age } → Shape #2 (새 구조)
```

그래서 너무 자주 구조를 바꾸면 성능이 떨어집니다.

실무에서는 **“객체 구조는 가능하면 고정해라”** 라는 룰을 쓰는 이유예요.

## 메모리로 설명

---

| 용어 | 뜻 |
| --- | --- |
| **컴파일타임(Compile time)** | 코드를 분석·번역해서 실행할 수 있는 형태(바이트코드, 머신코드 등)로 만드는 단계 |
| **런타임(Runtime)** | 그 코드가 실제로 실행되어, 메모리에 객체가 만들어지고 함수가 호출되는 단계 |
| **스택(Stack)** | 함수 호출, 지역 변수, 호출 순서를 저장하는 메모리 영역 (작고 빠름) |
| **힙(Heap)** | 동적으로 생성된 객체가 저장되는 영역 (크고 느림, GC의 대상) |

### 클래스 기반 언어의 메모리 흐름 (예: Java, C++)

```jsx
class Dog {
    int age;
    void bark() { System.out.println("멍멍"); }
}

Dog dog = new Dog();
```

**메모리 구성**

```jsx
[컴파일타임]
 ├── Class Table (Dog)
 │    ├── 필드 오프셋, 메서드 주소(vtable)
 │    └── 고정된 구조
 └── 실행 파일로 포함됨

[런타임]
 ├── Stack
 │    └── 변수 dog → (Dog 객체의 참조)
 └── Heap
      └── Dog 객체 실제 데이터
            ├── age: 0
            ├── vtable ptr → bark()
            └── 클래스정보 포인터 (Dog)

```

- 클래스(설계도)는 컴파일타임에 고정되어 **코드 영역**에 저장
- 실제 인스턴스(`dog`)는 런타임에 **힙**에 생성
- 스택에는 객체 “참조 주소”만 저장됨

### 프로토타입 기반 언어의 메모리 흐름 (JavaScript)

```jsx
function Dog() { this.age = 0; }
Dog.prototype.bark = function() { console.log("멍멍"); };

const dog = new Dog();

```

메모리 구성

```jsx
[런타임]
 ├── Heap
 │   ├── Function Object: Dog
 │   │     ├── [[Prototype]] → Function.prototype
 │   │     ├── prototype → (Dog.prototype 객체)
 │   │     └── 코드영역 포인터 (bark 구현)
 │   │
 │   ├── Object: Dog.prototype
 │   │     ├── bark: function
 │   │     └── [[Prototype]] → Object.prototype
 │   │
 │   └── Object: dog
 │         ├── age: 0
 │         └── [[Prototype]] → Dog.prototype
 │
 └── Stack
       └── dog 변수 → (힙의 dog 객체 주소)

```

- JS는 **컴파일 단계에 클래스 구조가 고정되지 않음**
- `Dog`, `Dog.prototype`, `dog` 모두 **힙에 동적으로 할당**
- 각 객체는 자신의 `[[Prototype]]` 포인터를 따라 체인으로 연결됨

- 런타임.
    
    > ✅ 맞아요.
    > 
    > 
    > “JS가 런타임 구조를 갖는 이유는 단순히 프로토타입 때문이 아니라,
    > 
    > **프로토타입 모델 + JS 엔진의 메모리 관리 방식**이 결합되어 만들어진 결과예요.”
    > 
    
    이걸 이해하려면 이렇게 3단계로 분리해서 보면 딱 정리됩니다 👇
    
    ---
    
    ## 🧩 1️⃣ “런타임 구조”라는 말은 어디서 오는가?
    
    ### 💬 핵심:
    
    **런타임 구조**는 “언제 객체의 형태와 관계가 결정되느냐”를 말합니다.
    
    - Java / C++: **컴파일타임에 고정** → 정적 구조
    - JavaScript: **실행 중에 결정** → 동적 구조
    
    이건 JS의 언어 **철학적 설계(프로토타입 모델)** 때문에 생긴 거예요.
    
    즉, JS는 처음부터 “객체를 실행 중에 만들고 바꾸는 언어”로 설계됐죠.
    
    📘 **정리:**
    
    > “런타임 구조”라는 개념 자체는 언어의 철학(프로토타입) 에서 비롯된다.
    > 
    
    ---
    
    ## ⚙️ 2️⃣ 그런데 그걸 “가능하게 하는 것”은 엔진의 메모리 설계다
    
    이제 여기서 JS 엔진(V8, SpiderMonkey 등)의 역할이 중요해요.
    
    **프로토타입 철학**은 “객체끼리 연결할 수 있다”는 규칙만 정의할 뿐이고,
    
    그걸 실제로 **어떻게 효율적으로 메모리에서 표현할지**는 엔진이 담당합니다.
    
    ### 💡 JS 엔진이 쓰는 기술들:
    
    | 개념 | 설명 |
    | --- | --- |
    | **Hidden Class / Shape** | 객체의 속성 레이아웃을 동적으로 관리 (C++의 vtable 비슷하지만 가변형) |
    | **Property Table (Dictionary Mode)** | 객체마다 key-value 테이블을 힙에 저장 (해시 기반) |
    | **Inline Cache (IC)** | 최근 접근한 프로퍼티의 메모리 위치를 캐싱해 lookup 속도 향상 |
    | **GC (Garbage Collection)** | 런타임에 객체를 자동 해제 (힙 기반 동적 메모리 모델) |
    
    이런 엔진 구조가 있어야,
    
    `obj.newProp = 1` 같은 코드가 실행 중에 새 필드를 추가할 수 있는 거예요.
    
    즉, **“프로토타입의 유연함”을 실제로 구현하는 건 엔진의 동적 힙 메모리 모델**이에요.
    
    ---
    
    ## 🧬 3️⃣ 그러니까 “복합적”이 맞습니다 ✅
    
    | 계층 | 역할 | JS에서의 구현 |
    | --- | --- | --- |
    | 🧠 **언어 철학 (Spec 레벨)** | “객체는 다른 객체를 상속할 수 있다(프로토타입 체인)” | ECMAScript 사양의 [[Prototype]] 규칙 |
    | ⚙️ **엔진 구현 (VM 레벨)** | “그걸 어떻게 빠르게 메모리에서 구현할까?” | V8의 HiddenClass, Shape Transition, IC |
    | 💾 **메모리 구조 (시스템 레벨)** | “객체를 어디에 저장하고 언제 해제할까?” | Heap에 객체 저장, GC로 메모리 관리 |
    
    > 🔁 즉, JS의 “런타임 구조”는
    > 
    > 
    > 프로토타입 모델(언어 철학)이 만든 **유연성**과
    > 
    > 엔진의 동적 메모리 구조가 만든 **실현 기술**의 결합이에요.
    > 
    
    ---
    
    ## 📊 4️⃣ 시각으로 보면
    
    ```
    ┌────────────────────────────┐
    │  ECMAScript 언어 설계(철학) │   ← "프로토타입 기반 OOP"
    │  ├─ 객체 간 연결 허용         │
    │  └─ 런타임 구조 자유           │
    └────────────┬──────────────┘
                 │
                 ▼
    ┌────────────────────────────┐
    │  JS 엔진 구현 (V8 등)       │
    │  ├─ Hidden Class / Shape   │ ← 구조를 동적으로 추적
    │  ├─ Property Table 관리     │
    │  └─ GC / Inline Cache 등   │
    └────────────┬──────────────┘
                 │
                 ▼
    ┌────────────────────────────┐
    │  실제 메모리 구조 (힙)       │
    │  ├─ 객체들이 동적으로 생성   │
    │  ├─ [[Prototype]] 링크 저장  │
    │  └─ 구조 변경시 Shape 교체   │
    └────────────────────────────┘
    
    ```
    
    ---
    
    ## 📘 요약 정리
    
    | 구분 | 프로토타입의 역할 | 엔진의 역할 |
    | --- | --- | --- |
    | **정의(규칙)** | 객체가 객체를 상속할 수 있다는 언어적 모델 | 없음 (사양만 따름) |
    | **구현(메커니즘)** | 없음 (엔진이 구현해야 함) | Hidden Class, Heap, Shape |
    | **메모리 구조 결정** | 사양엔 언급 없음 | 엔진이 동적으로 관리 |
    | **런타임 구조가 생긴 이유** | 객체 모델이 유연하기 때문 | 그 유연성을 지원하기 위해 동적 메모리 구조로 설계됐기 때문 |
    
    ---
    
    ## 🧠 한 문장 정리
    
    > JS의 런타임 구조는 “프로토타입이라는 언어 모델”이 만들어낸 유연성을,
    엔진이 “동적 메모리 구조(힙 + Hidden Class)”로 구현했기 때문에 생긴 복합적 결과입니다.
    > 
    
    ---
    
    원하신다면 다음 단계로
    
    🧩 “V8 엔진의 Hidden Class 변화(Shape Transition)”를
    
    “객체에 속성을 추가할 때 내부적으로 어떤 일이 일어나는가”를
    
    **진짜 메모리 변환 다이어그램**으로 보여드릴까요?
    
    (이게 보면 ‘런타임 구조’가 구체적으로 어떻게 생성되고 변경되는지 완전히 감이 잡혀요.)
